const fs = require('fs');
const path = require('path');

// Configuration des co√ªts et valeurs
const CONFIG = {
  UNIT_COSTS: {
    fantassin: 50,
    archer: 75,
    chevalier: 150,
    mage: 250,
    dragon: 750
  },
  UNIT_STRENGTH: {
    fantassin: 1,
    archer: 1.5,
    chevalier: 3,
    mage: 5,
    dragon: 15
  },
  TACTICS: {
    frontale: 1.0,
    surprise: 1.3,
    siege: 0.8
  },
  RANKS: {
    0: { name: 'Bronze', bonus: 1.0, dailyGold: 100 },
    500: { name: 'Argent', bonus: 1.2, dailyGold: 150 },
    1500: { name: 'Or', bonus: 1.5, dailyGold: 200 },
    3000: { name: 'L√©gende', bonus: 2.0, dailyGold: 300 }
  },
  GRADES: ['Membre', 'Soldat', 'G√©n√©ral', 'Espion', 'Tr√©sorier', 'Lieutenant', 'Chef'],
  BLASONS: ['üê∫', 'ü¶Ö', 'ü¶Å', 'üêâ', '‚öîÔ∏è', 'üõ°Ô∏è', 'üè∞', 'üëë', 'üî•', '‚ùÑÔ∏è', '‚ö°', 'üåü'],
  BASES: [
    'For√™t Obscure', 'Montagne Glac√©e', 'D√©sert Br√ªlant', 'Marais Mystique',
    'Vall√©e Perdue', 'Citadelle de Pierre', 'Tour de Cristal', '√éle Flottante',
    'Caverne Profonde', 'Plaine √âternelle', 'Jungle Sauvage', 'Toundra Gel√©e'
  ],
  COOLDOWNS: {
    attack: 5 * 60 * 1000,      // 5 minutes
    recruit: 2 * 60 * 1000,     // 2 minutes
    declare: 10 * 60 * 1000,    // 10 minutes
    daily_reward: 60 * 60 * 1000 // 1 heure
  }
};

class ClanSystem {
  constructor() {
    this.dataDir = path.join(__dirname, '..', 'data', 'clan');
    this.clansFile = path.join(this.dataDir, 'clans.json');
    this.warsFile = path.join(this.dataDir, 'wars.json');
    this.timersFile = path.join(this.dataDir, 'timers.json');
    this.eventsFile = path.join(this.dataDir, 'events.json');
    this.requestsFile = path.join(this.dataDir, 'requests.json');
    this.ensureDataDir();
  }

  ensureDataDir() {
    if (!fs.existsSync(this.dataDir)) {
      fs.mkdirSync(this.dataDir, { recursive: true });
    }
    
    // Initialiser les fichiers s'ils n'existent pas
    const files = [
      { file: this.clansFile, default: {} },
      { file: this.warsFile, default: {} },
      { file: this.timersFile, default: {} },
      { file: this.eventsFile, default: {} },
      { file: this.requestsFile, default: {} }
    ];

    files.forEach(({ file, default: defaultValue }) => {
      if (!fs.existsSync(file)) {
        fs.writeFileSync(file, JSON.stringify(defaultValue, null, 2));
      }
    });
  }

  loadData(file) {
    try {
      const data = fs.readFileSync(file, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      console.error(`Erreur lors du chargement de ${file}:`, error);
      return {};
    }
  }

  saveData(file, data) {
    try {
      fs.writeFileSync(file, JSON.stringify(data, null, 2));
      return true;
    } catch (error) {
      console.error(`Erreur lors de la sauvegarde de ${file}:`, error);
      return false;
    }
  }

  // Getters et setters pour les donn√©es
  getClans() { return this.loadData(this.clansFile); }
  saveClans(clans) { return this.saveData(this.clansFile, clans); }
  
  getWars() { return this.loadData(this.warsFile); }
  saveWars(wars) { return this.saveData(this.warsFile, wars); }
  
  getTimers() { return this.loadData(this.timersFile); }
  saveTimers(timers) { return this.saveData(this.timersFile, timers); }
  
  getEvents() { return this.loadData(this.eventsFile); }
  saveEvents(events) { return this.saveData(this.eventsFile, events); }
  
  getRequests() { return this.loadData(this.requestsFile); }
  saveRequests(requests) { return this.saveData(this.requestsFile, requests); }

  // Utilitaires
  getUserClan(userId) {
    const clans = this.getClans();
    for (const [clanName, clan] of Object.entries(clans)) {
      if (clan.membres && clan.membres[userId]) {
        return { name: clanName, data: clan };
      }
    }
    return null;
  }

  getRank(points) {
    const ranks = Object.keys(CONFIG.RANKS).map(p => parseInt(p)).sort((a, b) => b - a);
    for (const rankPoints of ranks) {
      if (points >= rankPoints) {
        return CONFIG.RANKS[rankPoints];
      }
    }
    return CONFIG.RANKS[0];
  }

  canPerformAction(userId, action) {
    const timers = this.getTimers();
    const userTimers = timers[userId] || {};
    const lastAction = userTimers[action];
    
    if (!lastAction) return true;
    
    const cooldown = CONFIG.COOLDOWNS[action] || 0;
    return Date.now() - lastAction > cooldown;
  }

  setActionTimer(userId, action) {
    const timers = this.getTimers();
    if (!timers[userId]) timers[userId] = {};
    timers[userId][action] = Date.now();
    this.saveTimers(timers);
  }

  getTimeRemaining(userId, action) {
    const timers = this.getTimers();
    const userTimers = timers[userId] || {};
    const lastAction = userTimers[action];
    
    if (!lastAction) return 0;
    
    const cooldown = CONFIG.COOLDOWNS[action] || 0;
    const remaining = cooldown - (Date.now() - lastAction);
    return Math.max(0, remaining);
  }

  formatTime(ms) {
    const totalMinutes = Math.floor(ms / (1000 * 60));
    const hours = Math.floor(totalMinutes / 60);
    const minutes = totalMinutes % 60;
    const seconds = Math.floor((ms % (1000 * 60)) / 1000);
    
    if (hours > 0) {
      return `${hours}h ${minutes}min`;
    } else if (minutes > 0) {
      return `${minutes}min${seconds > 0 ? ` ${seconds}s` : ''}`;
    } else {
      return `${seconds}s`;
    }
  }

  calculateForce(units) {
    let force = 0;
    for (const [type, count] of Object.entries(units || {})) {
      force += count * (CONFIG.UNIT_STRENGTH[type] || 0);
    }
    return force;
  }

  simulateBattle(attackerForce, defenderForce, tactic = 'frontale') {
    const tacticMultiplier = CONFIG.TACTICS[tactic] || 1.0;
    const adjustedAttackerForce = attackerForce * tacticMultiplier;
    
    // Facteur al√©atoire (-20% √† +20%)
    const attackerRoll = adjustedAttackerForce * (0.8 + Math.random() * 0.4);
    const defenderRoll = defenderForce * (0.8 + Math.random() * 0.4);
    
    const victory = attackerRoll > defenderRoll;
    const ratio = victory ? attackerRoll / defenderRoll : defenderRoll / attackerRoll;
    
    // Calcul des pertes (entre 10% et 40% des unit√©s)
    const baseLoss = 0.1;
    const maxLoss = 0.4;
    const lossPercentage = Math.min(maxLoss, baseLoss + (2 - ratio) * 0.15);
    
    return {
      victory,
      ratio: Math.round(ratio * 100) / 100,
      attackerLosses: lossPercentage,
      defenderLosses: victory ? lossPercentage * 1.2 : lossPercentage * 0.8
    };
  }

  applyLosses(units, lossPercentage) {
    const losses = {};
    for (const [type, count] of Object.entries(units || {})) {
      const lost = Math.floor(count * lossPercentage);
      losses[type] = lost;
      units[type] = Math.max(0, count - lost);
    }
    return losses;
  }

  distributeLossesToMembers(clan, totalLosses) {
    const members = Object.values(clan.membres);
    
    for (const [unitType, totalLost] of Object.entries(totalLosses)) {
      let remaining = totalLost;
      
      // Calculer le total de ce type d'unit√© dans le clan
      const totalUnits = members.reduce((sum, member) => 
        sum + (member.unites[unitType] || 0), 0);
      
      if (totalUnits === 0) continue;
      
      // Distribuer les pertes proportionnellement
      for (const member of members) {
        if (remaining <= 0) break;
        
        const memberUnits = member.unites[unitType] || 0;
        if (memberUnits === 0) continue;
        
        const memberRatio = memberUnits / totalUnits;
        const memberLosses = Math.min(remaining, Math.floor(totalLost * memberRatio));
        
        member.unites[unitType] = Math.max(0, memberUnits - memberLosses);
        remaining -= memberLosses;
      }
    }
  }

  // Commandes principales
  async processCommand(userId, userPseudo, args) {
    const subcommand = args[0]?.toLowerCase();
    
    switch (subcommand) {
      case 'create':
        return this.createClan(userId, userPseudo, args.slice(1).join(' '));
      case 'join':
        return this.requestJoinClan(userId, userPseudo, args[1]);
      case 'accept':
        return this.acceptJoinRequest(userId, args[1]);
      case 'reject':
        return this.rejectJoinRequest(userId, args[1]);
      case 'leave':
        return this.leaveClan(userId);
      case 'info':
        return this.getClanInfo(userId, args[1]);
      case 'promote':
        return this.promoteMember(userId, args[1], args[2]);
      case 'kick':
        return this.kickMember(userId, args[1]);
      case 'recruit':
        return this.recruitUnits(userId, args[1], parseInt(args[2]) || 1);
      case 'declare':
        return this.declareWar(userId, args[1]);
      case 'attack':
        return this.attackClan(userId, args[1] || 'frontale');
      case 'defend':
        return this.defendClan(userId);
      case 'peace':
        return this.proposePeace(userId, args.slice(1).join(' '));
      case 'ranking':
        return this.getClanRanking();
      case 'daily':
        return this.claimDailyReward(userId);
      case 'donate':
        return this.donateGold(userId, parseInt(args[1]) || 0);
      case 'wars':
        return this.getActiveWars();
      case 'stats':
        return this.getClanStats(userId);
      case 'help':
        return this.getHelp();
      default:
        return this.getQuickHelp();
    }
  }

  createClan(userId, userPseudo, clanName) {
    if (!clanName || clanName.trim().length === 0) {
      return "‚ùå **Erreur:** Sp√©cifie un nom pour ton clan !\n`/clan create [NomClan]`";
    }

    clanName = clanName.trim();
    
    if (clanName.length > 20) {
      return "‚ùå **Erreur:** Le nom du clan ne peut pas d√©passer 20 caract√®res !";
    }

    const clans = this.getClans();
    
    // V√©rifier si le clan existe d√©j√† (insensible √† la casse)
    const existingClan = Object.keys(clans).find(name => 
      name.toLowerCase() === clanName.toLowerCase()
    );
    
    if (existingClan) {
      return `‚ùå **Erreur:** Le clan "${existingClan}" existe d√©j√† !`;
    }

    if (this.getUserClan(userId)) {
      return "‚ùå **Erreur:** Tu fais d√©j√† partie d'un clan ! Quitte-le d'abord avec `/clan leave`";
    }

    const blason = CONFIG.BLASONS[Math.floor(Math.random() * CONFIG.BLASONS.length)];
    const base = CONFIG.BASES[Math.floor(Math.random() * CONFIG.BASES.length)];

    clans[clanName] = {
      blason,
      chef: userId,
      base,
      or: 1000,
      points: 0,
      statut: "neutre",
      createdAt: Date.now(),
      lastDailyReward: 0,
      territoires: 1,
      defenseBonuses: {},
      membres: {
        [userId]: {
          pseudo: userPseudo,
          grade: "Chef",
          unites: { 
            fantassin: 5, 
            archer: 3 
          },
          pointsPerso: 0,
          joinedAt: Date.now(),
          donations: 0
        }
      }
    };

    this.saveClans(clans);

    return `üè∞ **Clan cr√©√© avec succ√®s !**\n\n` +
           `${blason} **${clanName}**\n` +
           `üìç **Base:** ${base}\n` +
           `üëë **Chef:** ${userPseudo}\n` +
           `üí∞ **Or:** 1,000\n` +
           `‚≠ê **Points:** 0\n` +
           `üè¥ **Territoires:** 1\n\n` +
           `üõ°Ô∏è **Arm√©e de d√©part:**\n` +
           `‚Ä¢ Fantassins: 5\n` +
           `‚Ä¢ Archers: 3\n\n` +
           `Ton clan est maintenant op√©rationnel ! Utilise \`/clan help\` pour voir toutes les commandes disponibles.`;
  }

  requestJoinClan(userId, userPseudo, clanName) {
    if (!clanName) {
      return "‚ùå **Erreur:** Sp√©cifie le nom du clan √† rejoindre !\n`/clan join [NomClan]`";
    }

    const clans = this.getClans();
    
    // Recherche insensible √† la casse
    const foundClan = Object.keys(clans).find(name => 
      name.toLowerCase() === clanName.toLowerCase()
    );
    
    if (!foundClan) {
      return `‚ùå **Erreur:** Le clan "${clanName}" n'existe pas !`;
    }

    if (this.getUserClan(userId)) {
      return "‚ùå **Erreur:** Tu fais d√©j√† partie d'un clan !";
    }

    const requests = this.getRequests();
    const requestId = `${userId}_${foundClan}`;

    if (requests[requestId]) {
      return `‚è≥ **Demande en attente**\n\nTu as d√©j√† une demande en cours pour rejoindre **${foundClan}**.`;
    }

    requests[requestId] = {
      userId,
      userPseudo,
      clanName: foundClan,
      timestamp: Date.now()
    };

    this.saveRequests(requests);

    return `üì® **Demande envoy√©e !**\n\n` +
           `Ta demande pour rejoindre **${foundClan}** a √©t√© envoy√©e au chef du clan.\n` +
           `Tu recevras une notification quand elle sera trait√©e.`;
  }

  acceptJoinRequest(userId, targetPseudo) {
    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    const member = userClan.data.membres[userId];
    if (!member || !['Chef', 'Lieutenant'].includes(member.grade)) {
      return "‚ùå **Erreur:** Seuls les Chefs et Lieutenants peuvent accepter des demandes !";
    }

    const requests = this.getRequests();
    const requestEntry = Object.entries(requests).find(([_, request]) => 
      request.clanName === userClan.name && request.userPseudo === targetPseudo
    );

    if (!requestEntry) {
      return `‚ùå **Erreur:** Aucune demande trouv√©e pour **${targetPseudo}**.`;
    }

    const [requestId, request] = requestEntry;
    const clans = this.getClans();

    // Ajouter le membre au clan
    clans[userClan.name].membres[request.userId] = {
      pseudo: request.userPseudo,
      grade: "Membre",
      unites: { fantassin: 2 },
      pointsPerso: 0,
      joinedAt: Date.now(),
      donations: 0
    };

    // Supprimer la demande
    delete requests[requestId];

    this.saveClans(clans);
    this.saveRequests(requests);

    return `‚úÖ **Membre accept√© !**\n\n` +
           `**${request.userPseudo}** a rejoint le clan **${userClan.name}** !\n` +
           `üë• **Membres:** ${Object.keys(clans[userClan.name].membres).length}`;
  }

  rejectJoinRequest(userId, targetPseudo) {
    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    const member = userClan.data.membres[userId];
    if (!member || !['Chef', 'Lieutenant'].includes(member.grade)) {
      return "‚ùå **Erreur:** Seuls les Chefs et Lieutenants peuvent rejeter des demandes !";
    }

    const requests = this.getRequests();
    const requestEntry = Object.entries(requests).find(([_, request]) => 
      request.clanName === userClan.name && request.userPseudo === targetPseudo
    );

    if (!requestEntry) {
      return `‚ùå **Erreur:** Aucune demande trouv√©e pour **${targetPseudo}**.`;
    }

    const [requestId] = requestEntry;
    delete requests[requestId];
    this.saveRequests(requests);

    return `‚ùå **Demande rejet√©e**\n\nLa demande de **${targetPseudo}** a √©t√© rejet√©e.`;
  }

  leaveClan(userId) {
    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    const clans = this.getClans();
    const clan = clans[userClan.name];

    if (clan.chef === userId) {
      // Transf√©rer le leadership ou dissoudre le clan
      const otherMembers = Object.keys(clan.membres).filter(id => id !== userId);
      if (otherMembers.length > 0) {
        // Choisir le lieutenant le plus ancien, sinon le membre le plus ancien
        const lieutenants = otherMembers.filter(id => 
          clan.membres[id].grade === 'Lieutenant'
        );
        
        const newChef = lieutenants.length > 0 ? 
          lieutenants.sort((a, b) => clan.membres[a].joinedAt - clan.membres[b].joinedAt)[0] :
          otherMembers.sort((a, b) => clan.membres[a].joinedAt - clan.membres[b].joinedAt)[0];

        clan.chef = newChef;
        clan.membres[newChef].grade = "Chef";
        
        delete clan.membres[userId];
        this.saveClans(clans);
        
        return `‚úÖ **Clan transf√©r√©**\n\n` +
               `Tu as quitt√© **${userClan.name}**.\n` +
               `Le leadership a √©t√© transf√©r√© √† **${clan.membres[newChef].pseudo}**.`;
      } else {
        // Dissoudre le clan
        delete clans[userClan.name];
        this.saveClans(clans);
        return `üè∞ **Clan dissous**\n\nLe clan **${userClan.name}** a √©t√© dissous car tu √©tais le dernier membre.`;
      }
    }

    delete clan.membres[userId];
    this.saveClans(clans);

    return `‚úÖ **Clan quitt√©**\n\nTu as quitt√© le clan **${userClan.name}**.`;
  }

  getClanInfo(userId, targetClan = null) {
    let clan, clanName;
    
    if (targetClan) {
      const clans = this.getClans();
      const foundClan = Object.keys(clans).find(name => 
        name.toLowerCase() === targetClan.toLowerCase()
      );
      
      if (!foundClan) {
        return `‚ùå **Erreur:** Le clan "${targetClan}" n'existe pas !`;
      }
      
      clanName = foundClan;
      clan = clans[foundClan];
    } else {
      const userClan = this.getUserClan(userId);
      if (!userClan) {
        return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan ! Utilise `/clan info [NomClan]` pour voir un autre clan.";
      }
      clanName = userClan.name;
      clan = userClan.data;
    }

    const rank = this.getRank(clan.points);
    const membersList = Object.entries(clan.membres)
      .sort(([,a], [,b]) => {
        const gradeOrder = { 'Chef': 0, 'Lieutenant': 1, 'Tr√©sorier': 2, 'G√©n√©ral': 3, 'Espion': 4, 'Soldat': 5, 'Membre': 6 };
        return (gradeOrder[a.grade] || 6) - (gradeOrder[b.grade] || 6);
      })
      .map(([id, member]) => {
        const isUser = id === userId;
        const prefix = isUser ? 'üë§' : '‚Ä¢';
        return `${prefix} **${member.pseudo}** (${member.grade})`;
      })
      .join('\n');

    // Calculer l'arm√©e totale
    const totalUnits = Object.values(clan.membres).reduce((total, member) => {
      for (const [type, count] of Object.entries(member.unites || {})) {
        total[type] = (total[type] || 0) + count;
      }
      return total;
    }, {});

    const unitsDisplay = Object.entries(totalUnits)
      .filter(([_, count]) => count > 0)
      .map(([type, count]) => `${type}: ${count}`)
      .join(', ') || 'Aucune unit√©';

    const totalForce = this.calculateForce(totalUnits);
    
    // Informations sur les guerres
    const wars = this.getWars();
    const activeWar = Object.values(wars).find(war => 
      war.attacker === clanName || war.defender === clanName
    );

    let warInfo = '';
    if (activeWar) {
      const enemy = activeWar.attacker === clanName ? activeWar.defender : activeWar.attacker;
      const timeLeft = Math.max(0, activeWar.preparationEnd - Date.now());
      
      if (timeLeft > 0) {
        warInfo = `‚öîÔ∏è **Guerre:** Pr√©paration contre **${enemy}** (${this.formatTime(timeLeft)})\n`;
      } else {
        warInfo = `‚öîÔ∏è **Guerre:** Combat actif contre **${enemy}**\n`;
      }
    }

    // Demandes en attente (seulement pour les membres du clan)
    let requestsInfo = '';
    if (!targetClan || this.getUserClan(userId)?.name === clanName) {
      const requests = this.getRequests();
      const pendingRequests = Object.values(requests).filter(req => req.clanName === clanName);
      
      if (pendingRequests.length > 0) {
        requestsInfo = `\nüì® **Demandes en attente (${pendingRequests.length}):**\n` +
          pendingRequests.map(req => `‚Ä¢ ${req.userPseudo}`).join('\n') + '\n';
      }
    }

    return `${clan.blason} **${clanName}**\n\n` +
           `üëë **Chef:** ${clan.membres[clan.chef]?.pseudo || 'Inconnu'}\n` +
           `üìç **Base:** ${clan.base}\n` +
           `üí∞ **Or:** ${clan.or.toLocaleString()}\n` +
           `‚≠ê **Points:** ${clan.points}\n` +
           `üèÜ **Rang:** ${rank.name}\n` +
           `üè¥ **Territoires:** ${clan.territoires || 1}\n` +
           `‚ö° **Force totale:** ${totalForce}\n` +
           warInfo +
           `üìÖ **Cr√©√© le:** ${new Date(clan.createdAt).toLocaleDateString()}\n\n` +
           `üë• **Membres (${Object.keys(clan.membres).length}):**\n${membersList}\n\n` +
           `üõ°Ô∏è **Arm√©e totale:** ${unitsDisplay}` +
           requestsInfo;
  }

  promoteMember(userId, targetPseudo, grade) {
    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    const clan = userClan.data;
    const userMember = clan.membres[userId];

    if (!userMember || userMember.grade !== "Chef") {
      return "‚ùå **Erreur:** Seul le Chef peut promouvoir des membres !";
    }

    if (!grade || !CONFIG.GRADES.includes(grade)) {
      return `‚ùå **Erreur:** Grade invalide !\n**Grades disponibles:** ${CONFIG.GRADES.filter(g => g !== 'Chef').join(', ')}`;
    }

    if (grade === 'Chef') {
      return "‚ùå **Erreur:** Tu ne peux pas promouvoir quelqu'un Chef ! Utilise `/clan leave` pour transf√©rer le leadership.";
    }

    // Trouver le membre √† promouvoir
    const targetId = Object.keys(clan.membres).find(id => 
      clan.membres[id].pseudo.toLowerCase() === targetPseudo.toLowerCase()
    );

    if (!targetId) {
      return `‚ùå **Erreur:** Membre "${targetPseudo}" introuvable dans le clan !`;
    }

    if (targetId === userId) {
      return "‚ùå **Erreur:** Tu ne peux pas te promouvoir toi-m√™me !";
    }

    const clans = this.getClans();
    const oldGrade = clans[userClan.name].membres[targetId].grade;
    clans[userClan.name].membres[targetId].grade = grade;
    this.saveClans(clans);

    return `‚úÖ **Promotion r√©ussie !**\n\n` +
           `**${targetPseudo}** a √©t√© promu de **${oldGrade}** √† **${grade}** !`;
  }

  kickMember(userId, targetPseudo) {
    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    const clan = userClan.data;
    const userMember = clan.membres[userId];

    if (!userMember || !['Chef', 'Lieutenant'].includes(userMember.grade)) {
      return "‚ùå **Erreur:** Seuls les Chefs et Lieutenants peuvent expulser des membres !";
    }

    // Trouver le membre √† expulser
    const targetId = Object.keys(clan.membres).find(id => 
      clan.membres[id].pseudo.toLowerCase() === targetPseudo.toLowerCase()
    );

    if (!targetId) {
      return `‚ùå **Erreur:** Membre "${targetPseudo}" introuvable dans le clan !`;
    }

    if (targetId === userId) {
      return "‚ùå **Erreur:** Tu ne peux pas t'expulser toi-m√™me ! Utilise `/clan leave`.";
    }

    if (targetId === clan.chef) {
      return "‚ùå **Erreur:** Tu ne peux pas expulser le Chef !";
    }

    // Un Lieutenant ne peut pas expulser un autre Lieutenant
    const targetMember = clan.membres[targetId];
    if (userMember.grade === 'Lieutenant' && targetMember.grade === 'Lieutenant') {
      return "‚ùå **Erreur:** Un Lieutenant ne peut pas expulser un autre Lieutenant !";
    }

    const clans = this.getClans();
    delete clans[userClan.name].membres[targetId];
    this.saveClans(clans);

    return `‚úÖ **Membre expuls√© !**\n\n` +
           `**${targetPseudo}** a √©t√© expuls√© du clan **${userClan.name}**.`;
  }

  recruitUnits(userId, unitType, quantity) {
    if (!this.canPerformAction(userId, 'recruit')) {
      const timeLeft = this.getTimeRemaining(userId, 'recruit');
      return `‚è≥ **Cooldown actif !** Tu peux recruter dans ${this.formatTime(timeLeft)}.`;
    }

    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    if (!unitType || !CONFIG.UNIT_COSTS[unitType]) {
      const validTypes = Object.keys(CONFIG.UNIT_COSTS).join(', ');
      return `‚ùå **Erreur:** Type d'unit√© invalide !\n**Types disponibles:** ${validTypes}`;
    }

    if (quantity <= 0 || quantity > 100) {
      return "‚ùå **Erreur:** La quantit√© doit √™tre entre 1 et 100 !";
    }

    const cost = CONFIG.UNIT_COSTS[unitType] * quantity;
    const clan = userClan.data;

    if (clan.or < cost) {
      return `‚ùå **Or insuffisant !**\n\n` +
             `üí∞ **Co√ªt:** ${cost.toLocaleString()} or\n` +
             `üí∞ **Disponible:** ${clan.or.toLocaleString()} or\n` +
             `üí∞ **Manque:** ${(cost - clan.or).toLocaleString()} or`;
    }

    const clans = this.getClans();
    clans[userClan.name].or -= cost;
    
    const member = clans[userClan.name].membres[userId];
    if (!member.unites[unitType]) {
      member.unites[unitType] = 0;
    }
    member.unites[unitType] += quantity;

    this.saveClans(clans);
    this.setActionTimer(userId, 'recruit');

    const unitEmoji = {
      fantassin: '‚öîÔ∏è',
      archer: 'üèπ',
      chevalier: 'üêé',
      mage: 'üîÆ',
      dragon: 'üêâ'
    };

    return `${unitEmoji[unitType]} **Recrutement r√©ussi !**\n\n` +
           `üìà **+${quantity} ${unitType}(s)** ajout√©(s) √† ton arm√©e\n` +
           `üí∞ **-${cost.toLocaleString()} or** (Reste: ${clans[userClan.name].or.toLocaleString()} or)\n` +
           `‚è≥ **Prochain recrutement:** 2 minutes`;
  }

  declareWar(userId, targetClanName) {
    if (!this.canPerformAction(userId, 'declare')) {
      const timeLeft = this.getTimeRemaining(userId, 'declare');
      return `‚è≥ **Cooldown actif !** Tu peux d√©clarer la guerre dans ${this.formatTime(timeLeft)}.`;
    }

    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    const clan = userClan.data;
    const userMember = clan.membres[userId];

    if (!userMember || userMember.grade !== "Chef") {
      return "‚ùå **Erreur:** Seul le Chef peut d√©clarer la guerre !";
    }

    const clans = this.getClans();
    const foundTargetClan = Object.keys(clans).find(name => 
      name.toLowerCase() === targetClanName.toLowerCase()
    );

    if (!foundTargetClan) {
      return `‚ùå **Erreur:** Le clan "${targetClanName}" n'existe pas !`;
    }

    if (foundTargetClan === userClan.name) {
      return "‚ùå **Erreur:** Tu ne peux pas d√©clarer la guerre √† ton propre clan !";
    }

    // V√©rifier si une guerre est d√©j√† active
    const wars = this.getWars();
    const existingWar = Object.values(wars).find(war => 
      (war.attacker === userClan.name && war.defender === foundTargetClan) ||
      (war.attacker === foundTargetClan && war.defender === userClan.name)
    );

    if (existingWar) {
      return `‚öîÔ∏è **Guerre d√©j√† active !**\n\nUne guerre est d√©j√† en cours entre **${userClan.name}** et **${foundTargetClan}**.`;
    }

    const warId = `${userClan.name}_vs_${foundTargetClan}_${Date.now()}`;
    const preparationTime = 5 * 60 * 1000; // 5 minutes

    wars[warId] = {
      attacker: userClan.name,
      defender: foundTargetClan,
      startTime: Date.now(),
      preparationEnd: Date.now() + preparationTime,
      status: "preparation"
    };

    clans[userClan.name].statut = `guerre avec ${foundTargetClan}`;
    clans[foundTargetClan].statut = `guerre avec ${userClan.name}`;

    this.saveWars(wars);
    this.saveClans(clans);
    this.setActionTimer(userId, 'declare');

    const targetClan = clans[foundTargetClan];

    return `‚öîÔ∏è **GUERRE D√âCLAR√âE !**\n\n` +
           `${clan.blason} **${userClan.name}** VS ${targetClan.blason} **${foundTargetClan}**\n\n` +
           `‚è≥ **P√©riode de pr√©paration:** 5 minutes\n` +
           `üõ°Ô∏è **Consignes:**\n` +
           `‚Ä¢ Recrutez des unit√©s avec \`/clan recruit\`\n` +
           `‚Ä¢ Renforcez vos d√©fenses avec \`/clan defend\`\n` +
           `‚Ä¢ L'attaque sera possible apr√®s la pr√©paration\n\n` +
           `üéØ **Pr√©parez-vous pour la bataille !**`;
  }

  attackClan(userId, tactic = 'frontale') {
    if (!this.canPerformAction(userId, 'attack')) {
      const timeLeft = this.getTimeRemaining(userId, 'attack');
      return `‚è≥ **Cooldown actif !** Tu peux attaquer dans ${this.formatTime(timeLeft)}.`;
    }

    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    const validTactics = Object.keys(CONFIG.TACTICS);
    if (!validTactics.includes(tactic)) {
      return `‚ùå **Tactique invalide !**\n**Tactiques disponibles:** ${validTactics.join(', ')}`;
    }

    const wars = this.getWars();
    const activeWar = Object.values(wars).find(war => 
      (war.attacker === userClan.name || war.defender === userClan.name) && 
      war.status === "preparation"
    );

    if (!activeWar) {
      return "‚ùå **Erreur:** Aucune guerre active ! D√©clare d'abord la guerre avec `/clan declare [clan]`.";
    }

    if (Date.now() < activeWar.preparationEnd) {
      const timeLeft = activeWar.preparationEnd - Date.now();
      return `‚è≥ **P√©riode de pr√©paration !**\n\nLa bataille commencera dans ${this.formatTime(timeLeft)}.`;
    }

    const enemyClanName = activeWar.attacker === userClan.name ? activeWar.defender : activeWar.attacker;
    const clans = this.getClans();
    const userClanData = clans[userClan.name];
    const enemyClan = clans[enemyClanName];

    if (!enemyClan) {
      return "‚ùå **Erreur:** Le clan ennemi n'existe plus !";
    }

    // Calculer les arm√©es
    const userUnits = this.getTotalClanUnits(userClanData);
    const enemyUnits = this.getTotalClanUnits(enemyClan);

    const userForce = this.calculateForce(userUnits);
    const enemyForce = this.calculateForce(enemyUnits);

    if (userForce === 0) {
      return "‚ùå **Erreur:** Ton clan n'a aucune unit√© pour attaquer !";
    }

    // Simuler la bataille
    const battleResult = this.simulateBattle(userForce, enemyForce, tactic);

    // Appliquer les pertes
    const userLosses = this.applyLosses(userUnits, battleResult.attackerLosses);
    const enemyLosses = this.applyLosses(enemyUnits, battleResult.defenderLosses);

    // Distribuer les pertes aux membres
    this.distributeLossesToMembers(userClanData, userLosses);
    this.distributeLossesToMembers(enemyClan, enemyLosses);

    let result = "";
    let goldGained = 0;
    let pointsGained = 0;

    if (battleResult.victory) {
      goldGained = Math.floor(enemyClan.or * 0.25 + Math.random() * enemyClan.or * 0.15);
      pointsGained = Math.floor(50 + enemyClan.points * 0.1 + Math.random() * 30);
      
      userClanData.or += goldGained;
      userClanData.points += pointsGained;
      enemyClan.or = Math.max(0, enemyClan.or - goldGained);
      
      // Bonus de territoires pour le vainqueur
      if (Math.random() < 0.3) { // 30% de chance
        userClanData.territoires = (userClanData.territoires || 1) + 1;
        result = `üéâ **VICTOIRE √âCLATANTE !**\n\n` +
                `üí∞ **+${goldGained.toLocaleString()} or** pill√©\n` +
                `‚≠ê **+${pointsGained} points** de prestige\n` +
                `üè¥ **+1 territoire** conquis !\n`;
      } else {
        result = `üéâ **VICTOIRE !**\n\n` +
                `üí∞ **+${goldGained.toLocaleString()} or** pill√©\n` +
                `‚≠ê **+${pointsGained} points** de prestige\n`;
      }
    } else {
      // D√©faite - perdre des points et de l'or
      const goldLost = Math.floor(userClanData.or * 0.1);
      const pointsLost = Math.floor(userClanData.points * 0.05);
      
      userClanData.or = Math.max(0, userClanData.or - goldLost);
      userClanData.points = Math.max(0, userClanData.points - pointsLost);
      
      result = `üíÄ **D√âFAITE CUISANTE !**\n\n` +
              `üí∏ **-${goldLost.toLocaleString()} or** perdu\n` +
              `üìâ **-${pointsLost} points** de prestige\n` +
              `üòî Lourdes pertes subies...\n`;
    }

    // Finir la guerre
    const warId = Object.keys(wars).find(id => wars[id] === activeWar);
    delete wars[warId];
    userClanData.statut = "neutre";
    enemyClan.statut = "neutre";

    this.saveClans(clans);
    this.saveWars(wars);
    this.setActionTimer(userId, 'attack');

    // Affichage des pertes
    const userLossesText = Object.entries(userLosses)
      .filter(([_, count]) => count > 0)
      .map(([type, count]) => `${type}: -${count}`)
      .join(', ') || 'Aucune';

    const enemyLossesText = Object.entries(enemyLosses)
      .filter(([_, count]) => count > 0)
      .map(([type, count]) => `${type}: -${count}`)
      .join(', ') || 'Aucune';

    const tacticEmoji = {
      frontale: '‚öîÔ∏è',
      surprise: 'üó°Ô∏è',
      siege: 'üè∞'
    };

    return result +
           `${tacticEmoji[tactic]} **Tactique:** ${tactic} (x${CONFIG.TACTICS[tactic]})\n` +
           `‚ö° **Force d√©ploy√©e:** ${userForce} vs ${enemyForce}\n` +
           `üìä **Ratio:** ${battleResult.ratio}\n\n` +
           `üíî **Tes pertes:** ${userLossesText}\n` +
           `üíÄ **Pertes ennemies:** ${enemyLossesText}\n\n` +
           `üèÅ **La guerre contre ${enemyClanName} est termin√©e.**`;
  }

  getTotalClanUnits(clan) {
    return Object.values(clan.membres).reduce((total, member) => {
      for (const [type, count] of Object.entries(member.unites || {})) {
        total[type] = (total[type] || 0) + count;
      }
      return total;
    }, {});
  }

  defendClan(userId) {
    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    const wars = this.getWars();
    const activeWar = Object.values(wars).find(war => 
      war.attacker === userClan.name || war.defender === userClan.name
    );

    if (!activeWar) {
      return "‚ùå **Erreur:** Ton clan n'est pas en guerre ! Utilise cette commande pendant une guerre pour renforcer tes d√©fenses.";
    }

    const clans = this.getClans();
    const clan = clans[userClan.name];

    // Am√©liorer les bonus d√©fensifs
    if (!clan.defenseBonuses) clan.defenseBonuses = {};
    
    const bonusTypes = ['pi√®ges', 'tours', 'murailles', 'foss√©s'];
    const randomBonus = bonusTypes[Math.floor(Math.random() * bonusTypes.length)];
    
    clan.defenseBonuses[randomBonus] = (clan.defenseBonuses[randomBonus] || 0) + 1;
    
    // Co√ªt en or
    const cost = 100 + (clan.defenseBonuses[randomBonus] * 50);
    
    if (clan.or < cost) {
      return `‚ùå **Or insuffisant !**\n\nCo√ªt pour am√©liorer les ${randomBonus}: ${cost} or`;
    }

    clan.or -= cost;
    this.saveClans(clans);

    const defenseEmoji = {
      pi√®ges: 'ü™§',
      tours: 'üóº',
      murailles: 'üß±',
      foss√©s: 'üï≥Ô∏è'
    };

    return `üõ°Ô∏è **D√©fenses renforc√©es !**\n\n` +
           `${defenseEmoji[randomBonus]} **${randomBonus.charAt(0).toUpperCase() + randomBonus.slice(1)}** am√©lior√©(e)s (Niveau ${clan.defenseBonuses[randomBonus]})\n` +
           `üí∞ **Co√ªt:** ${cost} or\n` +
           `‚ö° **Bonus d√©fensif:** +${clan.defenseBonuses[randomBonus] * 5}%\n\n` +
           `Tes d√©fenses sont maintenant plus solides pour la prochaine bataille !`;
  }

  proposePeace(userId, terms = '') {
    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    const member = userClan.data.membres[userId];
    if (!member || !['Chef', 'Lieutenant'].includes(member.grade)) {
      return "‚ùå **Erreur:** Seuls les Chefs et Lieutenants peuvent proposer la paix !";
    }

    const wars = this.getWars();
    const activeWar = Object.values(wars).find(war => 
      war.attacker === userClan.name || war.defender === userClan.name
    );

    if (!activeWar) {
      return "‚ùå **Erreur:** Ton clan n'est pas en guerre !";
    }

    const enemyClanName = activeWar.attacker === userClan.name ? activeWar.defender : activeWar.attacker;

    // Proposer automatiquement la paix (simplifi√© pour cette version)
    const warId = Object.keys(wars).find(id => wars[id] === activeWar);
    delete wars[warId];

    const clans = this.getClans();
    clans[userClan.name].statut = "neutre";
    clans[enemyClanName].statut = "neutre";

    this.saveWars(wars);
    this.saveClans(clans);

    return `üïäÔ∏è **PAIX D√âCLAR√âE !**\n\n` +
           `La guerre entre **${userClan.name}** et **${enemyClanName}** est termin√©e.\n\n` +
           `üìú **Termes:** ${terms || 'Paix sans condition'}\n\n` +
           `Les deux clans peuvent maintenant reprendre leurs activit√©s normales.`;
  }

  getClanRanking() {
    const clans = this.getClans();
    const ranking = Object.entries(clans)
      .map(([name, clan]) => ({
        name,
        points: clan.points,
        blason: clan.blason,
        membres: Object.keys(clan.membres).length,
        or: clan.or,
        territoires: clan.territoires || 1
      }))
      .sort((a, b) => b.points - a.points)
      .slice(0, 15);

    if (ranking.length === 0) {
      return "üìä **Aucun clan n'existe encore !**\n\nSois le premier √† cr√©er un clan avec `/clan create [nom]` !";
    }

    let result = "üèÜ **CLASSEMENT DES CLANS**\n\n";
    
    ranking.forEach((clan, index) => {
      const rank = this.getRank(clan.points);
      let medal = '';
      
      if (index === 0) medal = 'ü•á';
      else if (index === 1) medal = 'ü•à';
      else if (index === 2) medal = 'ü•â';
      else medal = `**${index + 1}.**`;
      
      result += `${medal} ${clan.blason} **${clan.name}**\n` +
                `   ‚≠ê ${clan.points} pts ‚Ä¢ üë• ${clan.membres} ‚Ä¢ üè¥ ${clan.territoires} ‚Ä¢ üèÜ ${rank.name}\n\n`;
    });

    return result + `üìà **Classement mis √† jour en temps r√©el**`;
  }

  claimDailyReward(userId) {
    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    const clan = userClan.data;
    const now = Date.now();
    const lastReward = clan.lastDailyReward || 0;
    const oneDayMs = CONFIG.COOLDOWNS.daily_reward;

    if (now - lastReward < oneDayMs) {
      const timeLeft = oneDayMs - (now - lastReward);
      return `‚è≥ **R√©compense d√©j√† r√©clam√©e !**\n\nProchaine r√©compense dans ${this.formatTime(timeLeft)}.`;
    }

    const rank = this.getRank(clan.points);
    const baseReward = rank.dailyGold;
    const memberBonus = Math.floor(Object.keys(clan.membres).length / 3) * 25;
    const territoryBonus = (clan.territoires || 1) * 20;
    const totalReward = baseReward + memberBonus + territoryBonus;

    const clans = this.getClans();
    clans[userClan.name].or += totalReward;
    clans[userClan.name].lastDailyReward = now;
    this.saveClans(clans);

    return `üí∞ **R√âCOMPENSE QUOTIDIENNE !**\n\n` +
           `üèÜ **Rang ${rank.name}:** ${baseReward} or\n` +
           `üë• **Bonus membres:** ${memberBonus} or\n` +
           `üè¥ **Bonus territoires:** ${territoryBonus} or\n` +
           `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
           `üíé **Total:** ${totalReward.toLocaleString()} or ajout√© !\n\n` +
           `üí∞ **Or du clan:** ${clans[userClan.name].or.toLocaleString()}`;
  }

  donateGold(userId, amount) {
    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    if (amount <= 0) {
      return "‚ùå **Erreur:** Le montant doit √™tre positif !";
    }

    // Pour cette version simplifi√©e, on suppose que les utilisateurs ont de l'or personnel
    // Dans une vraie impl√©mentation, il faudrait un syst√®me d'√©conomie personnelle
    return "üí° **Fonctionnalit√© √† venir !**\n\nLe syst√®me de don personnel sera ajout√© dans une prochaine mise √† jour.";
  }

  getActiveWars() {
    const wars = this.getWars();
    const activeWars = Object.values(wars);

    if (activeWars.length === 0) {
      return "üïäÔ∏è **Aucune guerre active**\n\nTous les clans sont en paix pour le moment.";
    }

    let result = "‚öîÔ∏è **GUERRES ACTIVES**\n\n";

    activeWars.forEach(war => {
      const timeLeft = Math.max(0, war.preparationEnd - Date.now());
      const status = timeLeft > 0 ? 
        `üõ°Ô∏è Pr√©paration (${this.formatTime(timeLeft)})` : 
        `‚öîÔ∏è Combat actif`;

      result += `**${war.attacker}** VS **${war.defender}**\n` +
                `üìç **Statut:** ${status}\n` +
                `üìÖ **D√©but:** ${new Date(war.startTime).toLocaleString()}\n\n`;
    });

    return result;
  }

  getClanStats(userId) {
    const userClan = this.getUserClan(userId);
    if (!userClan) {
      return "‚ùå **Erreur:** Tu ne fais partie d'aucun clan !";
    }

    const clan = userClan.data;
    const member = clan.membres[userId];
    
    // Statistiques personnelles
    const personalUnits = Object.entries(member.unites || {})
      .filter(([_, count]) => count > 0)
      .map(([type, count]) => `${type}: ${count}`)
      .join(', ') || 'Aucune';

    const personalForce = this.calculateForce(member.unites || {});

    // Statistiques du clan
    const totalUnits = this.getTotalClanUnits(clan);
    const totalForce = this.calculateForce(totalUnits);
    const rank = this.getRank(clan.points);

    return `üìä **STATISTIQUES**\n\n` +
           `üë§ **Tes stats personnelles:**\n` +
           `‚Ä¢ **Grade:** ${member.grade}\n` +
           `‚Ä¢ **Arm√©e:** ${personalUnits}\n` +
           `‚Ä¢ **Force:** ${personalForce}\n` +
           `‚Ä¢ **Points:** ${member.pointsPerso || 0}\n` +
           `‚Ä¢ **Membre depuis:** ${new Date(member.joinedAt).toLocaleDateString()}\n\n` +
           `${clan.blason} **Stats du clan ${userClan.name}:**\n` +
           `‚Ä¢ **Membres:** ${Object.keys(clan.membres).length}\n` +
           `‚Ä¢ **Or total:** ${clan.or.toLocaleString()}\n` +
           `‚Ä¢ **Points:** ${clan.points}\n` +
           `‚Ä¢ **Rang:** ${rank.name}\n` +
           `‚Ä¢ **Force totale:** ${totalForce}\n` +
           `‚Ä¢ **Territoires:** ${clan.territoires || 1}\n` +
           `‚Ä¢ **Cr√©√© le:** ${new Date(clan.createdAt).toLocaleDateString()}`;
  }

  getHelp() {
    return `‚öîÔ∏è **GUIDE COMPLET DU SYST√àME DE CLAN**\n\n` +
           `**üè∞ GESTION DE CLAN:**\n` +
           `‚Ä¢ \`/clan create [nom]\` - Cr√©er un clan\n` +
           `‚Ä¢ \`/clan join [nom]\` - Demander √† rejoindre un clan\n` +
           `‚Ä¢ \`/clan accept [pseudo]\` - Accepter une demande\n` +
           `‚Ä¢ \`/clan reject [pseudo]\` - Rejeter une demande\n` +
           `‚Ä¢ \`/clan leave\` - Quitter son clan\n` +
           `‚Ä¢ \`/clan info [clan]\` - Voir les infos d'un clan\n` +
           `‚Ä¢ \`/clan promote [pseudo] [grade]\` - Promouvoir\n` +
           `‚Ä¢ \`/clan kick [pseudo]\` - Expulser un membre\n\n` +
           `**‚öîÔ∏è GUERRE ET COMBAT:**\n` +
           `‚Ä¢ \`/clan declare [clan]\` - D√©clarer la guerre\n` +
           `‚Ä¢ \`/clan attack [tactique]\` - Attaquer (frontale/surprise/siege)\n` +
           `‚Ä¢ \`/clan defend\` - Renforcer les d√©fenses\n` +
           `‚Ä¢ \`/clan peace [termes]\` - Proposer la paix\n` +
           `‚Ä¢ \`/clan wars\` - Voir les guerres actives\n\n` +
           `**üõ°Ô∏è ARM√âE ET RESSOURCES:**\n` +
           `‚Ä¢ \`/clan recruit [type] [qt√©]\` - Recruter des unit√©s\n` +
           `‚Ä¢ **Types:** fantassin (50), archer (75), chevalier (150), mage (250), dragon (750)\n` +
           `‚Ä¢ \`/clan daily\` - R√©compense quotidienne\n\n` +
           `**üìä INFORMATION:**\n` +
           `‚Ä¢ \`/clan ranking\` - Classement des clans\n` +
           `‚Ä¢ \`/clan stats\` - Tes statistiques\n\n` +
           `**üí° CONSEILS:**\n` +
           `‚Ä¢ Chaque rang donne plus d'or quotidien\n` +
           `‚Ä¢ Les guerres ont 2h de pr√©paration\n` +
           `‚Ä¢ Cooldowns: Attaque 12h, Recrutement 30min, Guerre 24h\n` +
           `‚Ä¢ Grades: Membre ‚Üí Soldat ‚Üí G√©n√©ral/Espion/Tr√©sorier ‚Üí Lieutenant ‚Üí Chef`;
  }

  getQuickHelp() {
    return `‚öîÔ∏è **COMMANDES CLAN DISPONIBLES:**\n\n` +
           `**üè∞ Base:** create, join, leave, info, promote\n` +
           `**‚öîÔ∏è Guerre:** declare, attack, defend, peace\n` +
           `**üõ°Ô∏è Arm√©e:** recruit, daily, stats\n` +
           `**üìä Info:** ranking, wars, help\n\n` +
           `Utilise \`/clan help\` pour le guide complet !`;
  }
}

// Export pour utilisation dans le bot
module.exports = {
  name: 'clan',
  description: 'Syst√®me complet de gestion de clans avec guerres et strat√©gie',
  usage: '/clan [commande]',
  
  async execute(message, args) {
    try {
      const clanSystem = new ClanSystem();
      const userId = message.author?.id || message.from || 'unknown';
      const userPseudo = message.author?.username || message.pushname || 'Anonyme';
      
      const response = await clanSystem.processCommand(userId, userPseudo, args);
      
      // Adaptation pour diff√©rentes plateformes
      if (message.reply) {
        await message.reply(response);
      } else if (message.send) {
        await message.send(response);
      } else {
        console.log(response);
        return response;
      }
      
    } catch (error) {
      console.error('Erreur dans la commande clan:', error);
      const errorMsg = "‚ùå **Erreur technique !** R√©essaye dans quelques instants.";
      
      if (message.reply) {
        await message.reply(errorMsg);
      } else if (message.send) {
        await message.send(errorMsg);
      } else {
        return errorMsg;
      }
    }
  },

  // Fonction utilitaire pour les t√¢ches automatiques
  async runDailyTasks() {
    try {
      const clanSystem = new ClanSystem();
      const clans = clanSystem.getClans();
      let updated = false;

      for (const [clanName, clan] of Object.entries(clans)) {
        const now = Date.now();
        const lastReward = clan.lastDailyReward || 0;
        const oneDayMs = CONFIG.COOLDOWNS.daily_reward;

        // Attribution automatique des revenus quotidiens (si pas r√©clam√©s manuellement)
        if (now - lastReward >= oneDayMs * 2) { // 48h sans r√©clamation
          const rank = clanSystem.getRank(clan.points);
          const baseReward = rank.dailyGold;
          const memberBonus = Math.floor(Object.keys(clan.membres).length / 3) * 25;
          const territoryBonus = (clan.territoires || 1) * 20;
          const totalReward = Math.floor((baseReward + memberBonus + territoryBonus) * 0.5); // 50% du montant normal
          
          clan.or += totalReward;
          clan.lastDailyReward = now;
          updated = true;

          console.log(`Revenu automatique attribu√© au clan ${clanName}: +${totalReward} or`);
        }

        // D√©gradation progressive des bonus d√©fensifs
        if (clan.defenseBonuses) {
          for (const [bonus, level] of Object.entries(clan.defenseBonuses)) {
            if (level > 0 && Math.random() < 0.1) { // 10% de chance de d√©gradation par jour
              clan.defenseBonuses[bonus] = Math.max(0, level - 1);
              updated = true;
            }
          }
        }
      }

      if (updated) {
        clanSystem.saveClans(clans);
      }

      // Nettoyer les guerres expir√©es (plus de 7 jours)
      const wars = clanSystem.getWars();
      const sevenDaysMs = 7 * 24 * 60 * 60 * 1000;
      let warsUpdated = false;

      for (const [warId, war] of Object.entries(wars)) {
        if (now - war.startTime > sevenDaysMs) {
          delete wars[warId];
          warsUpdated = true;
          
          // Remettre les clans en statut neutre
          if (clans[war.attacker]) clans[war.attacker].statut = "neutre";
          if (clans[war.defender]) clans[war.defender].statut = "neutre";
          
          console.log(`Guerre expir√©e supprim√©e: ${war.attacker} vs ${war.defender}`);
        }
      }

      if (warsUpdated) {
        clanSystem.saveWars(wars);
        if (updated) clanSystem.saveClans(clans);
      }

      // Nettoyer les demandes de rejoindre expir√©es (plus de 3 jours)
      const requests = clanSystem.getRequests();
      const threeDaysMs = 3 * 24 * 60 * 60 * 1000;
      let requestsUpdated = false;

      for (const [requestId, request] of Object.entries(requests)) {
        if (now - request.timestamp > threeDaysMs) {
          delete requests[requestId];
          requestsUpdated = true;
        }
      }

      if (requestsUpdated) {
        clanSystem.saveRequests(requests);
      }

      // Nettoyer les timers expir√©s (plus de 30 jours)
      const timers = clanSystem.getTimers();
      const thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;
      let timersUpdated = false;

      for (const [userId, userTimers] of Object.entries(timers)) {
        for (const [action, timestamp] of Object.entries(userTimers)) {
          if (now - timestamp > thirtyDaysMs) {
            delete timers[userId][action];
            timersUpdated = true;
          }
        }
        
        // Supprimer les utilisateurs sans timers
        if (Object.keys(timers[userId]).length === 0) {
          delete timers[userId];
          timersUpdated = true;
        }
      }

      if (timersUpdated) {
        clanSystem.saveTimers(timers);
      }

    } catch (error) {
      console.error('Erreur lors des t√¢ches quotidiennes du clan:', error);
    }
  },

  // Fonction pour g√©n√©rer des √©v√©nements al√©atoires
  async generateRandomEvent() {
    try {
      const clanSystem = new ClanSystem();
      const clans = clanSystem.getClans();
      const clanNames = Object.keys(clans);
      
      if (clanNames.length === 0) return null;

      const events = [
        {
          type: 'treasure',
          name: 'Tr√©sor Ancien',
          description: 'd√©couvre un tr√©sor ancien dans les ruines',
          emoji: 'üí∞',
          rarity: 'rare',
          effect: (clan) => {
            const bonus = Math.floor(Math.random() * 800) + 300;
            clan.or += bonus;
            return `üí∞ +${bonus.toLocaleString()} or trouv√© !`;
          }
        },
        {
          type: 'plague',
          name: 'Maladie Myst√©rieuse',
          description: 'est frapp√© par une myst√©rieuse √©pid√©mie',
          emoji: 'üíÄ',
          rarity: 'rare',
          effect: (clan) => {
            let totalLost = 0;
            for (const member of Object.values(clan.membres)) {
              for (const [type, count] of Object.entries(member.unites || {})) {
                const lost = Math.floor(count * (0.05 + Math.random() * 0.1)); // 5-15% de pertes
                member.unites[type] = Math.max(0, count - lost);
                totalLost += lost;
              }
            }
            return `üíÄ ${totalLost} unit√©s perdues √† cause de la maladie`;
          }
        },
        {
          type: 'blessing',
          name: 'B√©n√©diction Divine',
          description: 're√ßoit la b√©n√©diction des anciens dieux',
          emoji: '‚ú®',
          rarity: '√©pique',
          effect: (clan) => {
            const pointsBonus = Math.floor(Math.random() * 150) + 75;
            const goldBonus = Math.floor(Math.random() * 500) + 200;
            clan.points += pointsBonus;
            clan.or += goldBonus;
            return `‚ú® +${pointsBonus} points et +${goldBonus.toLocaleString()} or b√©nis !`;
          }
        },
        {
          type: 'recruitment',
          name: 'Vague de Recrutement',
          description: 'attire de nouveaux guerriers courageux',
          emoji: '‚öîÔ∏è',
          rarity: 'commun',
          effect: (clan) => {
            const members = Object.values(clan.membres);
            if (members.length === 0) return 'Aucun membre pour recevoir les recrues.';
            
            const randomMember = members[Math.floor(Math.random() * members.length)];
            const unitTypes = ['fantassin', 'archer'];
            const randomType = unitTypes[Math.floor(Math.random() * unitTypes.length)];
            const count = Math.floor(Math.random() * 5) + 2;
            
            if (!randomMember.unites[randomType]) randomMember.unites[randomType] = 0;
            randomMember.unites[randomType] += count;
            
            return `‚öîÔ∏è +${count} ${randomType}(s) ont rejoint ${randomMember.pseudo} !`;
          }
        },
        {
          type: 'merchant',
          name: 'Marchand G√©n√©reux',
          description: 're√ßoit la visite d\'un marchand g√©n√©reux',
          emoji: 'üè™',
          rarity: 'commun',
          effect: (clan) => {
            const discount = Math.floor(Math.random() * 30) + 20; // 20-50% de r√©duction
            // Pour simplifier, on donne de l'or √©quivalent √† la r√©duction
            const bonus = Math.floor(Math.random() * 300) + 150;
            clan.or += bonus;
            return `üè™ Commerce florissant ! +${bonus.toLocaleString()} or gagn√©`;
          }
        },
        {
          type: 'territory',
          name: 'Expansion Territoriale',
          description: 'd√©couvre et revendique de nouvelles terres',
          emoji: 'üè¥',
          rarity: '√©pique',
          effect: (clan) => {
            if (Math.random() < 0.3) { // 30% de chance
              clan.territoires = (clan.territoires || 1) + 1;
              const bonus = 200 + (clan.territoires * 50);
              clan.or += bonus;
              return `üè¥ +1 territoire conquis ! +${bonus.toLocaleString()} or de revenus`;
            }
            return `üó∫Ô∏è Exploration sans succ√®s cette fois...`;
          }
        },
        {
          type: 'festival',
          name: 'Festival du Clan',
          description: 'organise un grand festival qui booste le moral',
          emoji: 'üéâ',
          rarity: 'commun',
          effect: (clan) => {
            const pointsBonus = Object.keys(clan.membres).length * 10;
            clan.points += pointsBonus;
            
            // Petit bonus d'unit√©s pour tous
            for (const member of Object.values(clan.membres)) {
              if (!member.unites.fantassin) member.unites.fantassin = 0;
              member.unites.fantassin += 1;
            }
            
            return `üéâ Festival r√©ussi ! +${pointsBonus} points et +1 fantassin par membre`;
          }
        },
        {
          type: 'sabotage',
          name: 'Sabotage Ennemi',
          description: 'subit un sabotage de ses d√©fenses',
          emoji: 'üî•',
          rarity: 'rare',
          effect: (clan) => {
            let totalDamage = 0;
            
            // R√©duire les bonus d√©fensifs
            if (clan.defenseBonuses) {
              for (const [bonus, level] of Object.entries(clan.defenseBonuses)) {
                const damage = Math.floor(level * 0.3);
                clan.defenseBonuses[bonus] = Math.max(0, level - damage);
                totalDamage += damage;
              }
            }
            
            // Perte d'or
            const goldLoss = Math.floor(clan.or * 0.05);
            clan.or = Math.max(0, clan.or - goldLoss);
            
            return `üî• Sabotage ! -${totalDamage} niveaux de d√©fense, -${goldLoss.toLocaleString()} or`;
          }
        }
      ];

      // Choisir un clan al√©atoirement
      const randomClan = clanNames[Math.floor(Math.random() * clanNames.length)];
      
      // Choisir un √©v√©nement bas√© sur la raret√©
      const rarityWeights = { commun: 60, rare: 30, √©pique: 10 };
      const totalWeight = Object.values(rarityWeights).reduce((a, b) => a + b, 0);
      let randomWeight = Math.random() * totalWeight;
      
      let selectedRarity = 'commun';
      for (const [rarity, weight] of Object.entries(rarityWeights)) {
        randomWeight -= weight;
        if (randomWeight <= 0) {
          selectedRarity = rarity;
          break;
        }
      }
      
      const availableEvents = events.filter(e => e.rarity === selectedRarity);
      const randomEvent = availableEvents[Math.floor(Math.random() * availableEvents.length)];
      
      const clan = clans[randomClan];
      const effectResult = randomEvent.effect(clan);
      
      clanSystem.saveClans(clans);

      // Enregistrer l'√©v√©nement
      const eventsLog = clanSystem.getEvents();
      const eventId = `${Date.now()}_${randomClan}`;
      
      eventsLog[eventId] = {
        clanName: randomClan,
        eventType: randomEvent.type,
        eventName: randomEvent.name,
        timestamp: Date.now(),
        effect: effectResult
      };
      
      clanSystem.saveEvents(eventsLog);

      return {
        clanName: randomClan,
        blason: clan.blason,
        rarity: selectedRarity,
        rarityEmoji: selectedRarity === '√©pique' ? 'üåü' : selectedRarity === 'rare' ? 'üíé' : 'üìú',
        message: `${randomEvent.emoji} **√âV√âNEMENT ${selectedRarity.toUpperCase()} !**\n\n` +
                 `${clan.blason} **${randomClan}** ${randomEvent.description} !\n\n` +
                 `${effectResult}\n\n` +
                 `üìÖ ${new Date().toLocaleString()}`
      };

    } catch (error) {
      console.error('Erreur lors de la g√©n√©ration d\'√©v√©nement:', error);
      return null;
    }
  },

  // Fonction pour obtenir les statistiques globales
  getGlobalStats() {
    try {
      const clanSystem = new ClanSystem();
      const clans = clanSystem.getClans();
      const wars = clanSystem.getWars();
      const events = clanSystem.getEvents();

      const totalClans = Object.keys(clans).length;
      const totalMembers = Object.values(clans).reduce((sum, clan) => 
        sum + Object.keys(clan.membres).length, 0);
      const activeWars = Object.keys(wars).length;
      const totalGold = Object.values(clans).reduce((sum, clan) => sum + clan.or, 0);
      const totalPoints = Object.values(clans).reduce((sum, clan) => sum + clan.points, 0);
      const totalTerritories = Object.values(clans).reduce((sum, clan) => sum + (clan.territoires || 1), 0);
      const totalEvents = Object.keys(events).length;

      // Calcul des unit√©s totales
      const totalUnits = Object.values(clans).reduce((total, clan) => {
        const clanUnits = Object.values(clan.membres).reduce((clanTotal, member) => {
          for (const [type, count] of Object.entries(member.unites || {})) {
            clanTotal[type] = (clanTotal[type] || 0) + count;
          }
          return clanTotal;
        }, {});
        
        for (const [type, count] of Object.entries(clanUnits)) {
          total[type] = (total[type] || 0) + count;
        }
        return total;
      }, {});

      const topClan = Object.entries(clans)
        .sort(([,a], [,b]) => b.points - a.points)[0];

      const mostActiveDay = Object.values(events)
        .reduce((acc, event) => {
          const day = new Date(event.timestamp).toDateString();
          acc[day] = (acc[day] || 0) + 1;
          return acc;
        }, {});
      
      const peakActivity = Object.entries(mostActiveDay)
        .sort(([,a], [,b]) => b - a)[0];

      return {
        totalClans,
        totalMembers,
        activeWars,
        totalGold,
        totalPoints,
        totalTerritories,
        totalEvents,
        totalUnits,
        averageMembersPerClan: totalClans > 0 ? Math.round(totalMembers / totalClans * 10) / 10 : 0,
        topClan: topClan ? { 
          name: topClan[0], 
          points: topClan[1].points, 
          blason: topClan[1].blason,
          members: Object.keys(topClan[1].membres).length
        } : null,
        peakActivity: peakActivity ? {
          date: peakActivity[0],
          events: peakActivity[1]
        } : null
      };

    } catch (error) {
      console.error('Erreur lors du calcul des statistiques globales:', error);
      return null;
    }
  },

  // Fonction pour obtenir l'historique des √©v√©nements d'un clan
  getClanEventHistory(clanName, limit = 10) {
    try {
      const clanSystem = new ClanSystem();
      const events = clanSystem.getEvents();
      
      const clanEvents = Object.values(events)
        .filter(event => event.clanName === clanName)
        .sort((a, b) => b.timestamp - a.timestamp)
        .slice(0, limit);

      return clanEvents;
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration de l\'historique:', error);
      return [];
    }
  },

  // Fonction pour nettoyer les donn√©es (maintenance)
  async cleanupData() {
    try {
      const clanSystem = new ClanSystem();
      
      // Supprimer les clans vides (sans membres)
      const clans = clanSystem.getClans();
      let clansUpdated = false;
      
      for (const [clanName, clan] of Object.entries(clans)) {
        if (!clan.membres || Object.keys(clan.membres).length === 0) {
          delete clans[clanName];
          clansUpdated = true;
          console.log(`Clan vide supprim√©: ${clanName}`);
        }
      }
      
      if (clansUpdated) {
        clanSystem.saveClans(clans);
      }

      // Nettoyer les √©v√©nements anciens (plus de 30 jours)
      const events = clanSystem.getEvents();
      const thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;
      let eventsUpdated = false;
      
      for (const [eventId, event] of Object.entries(events)) {
        if (Date.now() - event.timestamp > thirtyDaysMs) {
          delete events[eventId];
          eventsUpdated = true;
        }
      }
      
      if (eventsUpdated) {
        clanSystem.saveEvents(events);
      }

      console.log('Nettoyage des donn√©es termin√©');
      return true;
    } catch (error) {
      console.error('Erreur lors du nettoyage des donn√©es:', error);
      return false;
    }
  },

  // Configuration et classe export√©es pour acc√®s externe
  CONFIG,
  ClanSystem
};
