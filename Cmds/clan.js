/**
 * Commande /clan - Syst√®me de gestion de clans optimis√© avec v√©rifications avanc√©es
 * @param {string} senderId - ID de l'utilisateur
 * @param {string} args - Arguments de la commande
 * @param {object} ctx - Contexte partag√© du bot
 */
module.exports = async function cmdClan(senderId, args, ctx) {
    const { addToMemory, saveDataImmediate, sendMessage } = ctx;
    
    // Initialisation des donn√©es avec nouvelles structures
    const initClanData = () => ({
        clans: {}, // {id: {id, name, leader, members: [], level, xp, treasury, units: {w, a, m}, lastDefeat, lastBattles: {clanId: timestamp}}}
        userClans: {}, // {userId: clanId}
        battles: {}, // Historique complet des batailles
        invites: {}, // {userId: [clanIds]}
        deletedClans: {}, // {userId: deleteTimestamp} - cooldown 3 jours
        battleStats: {}, // Statistiques globales
        counter: 0
    });
    
    if (!ctx.clanData) {
        ctx.clanData = initClanData();
        await saveDataImmediate();
        ctx.log.info("üè∞ Structure des clans initialis√©e avec v√©rifications avanc√©es");
    }
    let data = ctx.clanData;
    
    const userId = String(senderId);
    const args_parts = args.trim().split(' ');
    const action = args_parts[0]?.toLowerCase();
    
    // === CONSTANTES DE JEU ===
    const GAME_CONFIG = {
        MAX_MEMBERS: 20,
        COOLDOWN_BETWEEN_SAME_CLANS: 60 * 60 * 1000, // 1h entre combats contre le m√™me clan
        PROTECTION_TIME: 60 * 60 * 1000, // 1h de protection apr√®s d√©faite
        CREATION_COOLDOWN: 3 * 24 * 60 * 60 * 1000, // 3 jours
        XP_PER_LEVEL: 1000,
        UNIT_COSTS: { w: 40, a: 60, m: 80 },
        UNIT_POWER: { w: 10, a: 8, m: 15 },
        BATTLE_REWARDS: {
            victory: { xp: 200, gold: 100 },
            draw: { xp: 100, gold: 0 },
            defeat: { xp: 50, gold: -50 }
        }
    };
    
    // === UTILITAIRES AVANC√âS ===
    
    // G√©n√©ration d'IDs courts s√©curis√©s
    const generateId = (type) => {
        data.counter = (data.counter || 0) + 1;
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let id = '';
        let num = data.counter + Date.now() % 10000;
        
        for (let i = 0; i < (type === 'clan' ? 4 : 3); i++) {
            id = chars[num % chars.length] + id;
            num = Math.floor(num / chars.length);
        }
        
        // V√©rifier l'unicit√©
        if (type === 'clan' && data.clans[id]) {
            return generateId(type); // R√©cursion si collision
        }
        return id;
    };
    
    const getUserClan = () => {
        const clanId = data.userClans[userId];
        return clanId ? data.clans[clanId] : null;
    };
    
    const findClan = (nameOrId) => {
        // Recherche par ID exact
        if (data.clans[nameOrId.toUpperCase()]) {
            return data.clans[nameOrId.toUpperCase()];
        }
        // Recherche par nom (insensible √† la casse)
        return Object.values(data.clans).find(c => 
            c.name.toLowerCase() === nameOrId.toLowerCase()
        );
    };
    
    const isLeader = () => {
        const clan = getUserClan();
        return clan?.leader === userId;
    };
    
    const canCreateClan = () => {
        const deleteTime = data.deletedClans[userId];
        if (!deleteTime) return true;
        return (Date.now() - deleteTime) > GAME_CONFIG.CREATION_COOLDOWN;
    };
    
    const getCooldownTime = () => {
        const deleteTime = data.deletedClans[userId];
        if (!deleteTime) return 0;
        return GAME_CONFIG.CREATION_COOLDOWN - (Date.now() - deleteTime);
    };
    
    const formatTime = (ms) => {
        const days = Math.floor(ms / (24 * 60 * 60 * 1000));
        const hours = Math.floor((ms % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
        const minutes = Math.floor((ms % (60 * 60 * 1000)) / (60 * 1000));
        
        if (days > 0) return `${days}j ${hours}h`;
        if (hours > 0) return `${hours}h ${minutes}m`;
        return `${minutes}m`;
    };
    
    // Calcul de puissance am√©lior√© avec bonus de niveau
    const calculatePower = (clan) => {
        if (!clan) return 0;
        
        // Base: niveau avec bonus exponentiel
        const levelBonus = clan.level * 100 + Math.pow(clan.level, 1.2) * 10;
        
        // Membres avec bonus de synergie
        const memberBonus = clan.members.length * 30;
        const synergyBonus = clan.members.length >= 10 ? clan.members.length * 5 : 0;
        
        // Unit√©s avec efficacit√©
        const unitPower = clan.units.w * GAME_CONFIG.UNIT_POWER.w + 
                         clan.units.a * GAME_CONFIG.UNIT_POWER.a + 
                         clan.units.m * GAME_CONFIG.UNIT_POWER.m;
        
        // Bonus XP progressif
        const xpBonus = Math.floor(clan.xp / 100) * 5;
        
        // Bonus de diversit√© d'unit√©s
        const unitTypes = [clan.units.w > 0, clan.units.a > 0, clan.units.m > 0].filter(Boolean).length;
        const diversityBonus = unitTypes * 20;
        
        return Math.floor(levelBonus + memberBonus + synergyBonus + unitPower + xpBonus + diversityBonus);
    };
    
    // V√©rifications de protection et cooldown
    const isProtected = (clan) => {
        if (!clan.lastDefeat) return false;
        return (Date.now() - clan.lastDefeat) < GAME_CONFIG.PROTECTION_TIME;
    };
    
    const canBattleAgainst = (attackerClan, defenderClan) => {
        if (!attackerClan.lastBattles) attackerClan.lastBattles = {};
        const lastBattle = attackerClan.lastBattles[defenderClan.id];
        if (!lastBattle) return true;
        return (Date.now() - lastBattle) > GAME_CONFIG.COOLDOWN_BETWEEN_SAME_CLANS;
    };
    
    const getNextBattleTime = (attackerClan, defenderClan) => {
        if (!attackerClan.lastBattles) return 0;
        const lastBattle = attackerClan.lastBattles[defenderClan.id];
        if (!lastBattle) return 0;
        return GAME_CONFIG.COOLDOWN_BETWEEN_SAME_CLANS - (Date.now() - lastBattle);
    };
    
    // Syst√®me XP avec v√©rification de niveau
    const addXP = (clan, amount) => {
        if (!clan || amount <= 0) return false;
        
        const oldLevel = clan.level;
        clan.xp += amount;
        const newLevel = Math.floor(clan.xp / GAME_CONFIG.XP_PER_LEVEL) + 1;
        
        if (newLevel > clan.level) {
            clan.level = newLevel;
            // Bonus de niveau: unit√©s gratuites
            const levelDiff = newLevel - oldLevel;
            clan.units.w += levelDiff * 2;
            clan.units.a += levelDiff;
            clan.units.m += Math.floor(levelDiff / 2);
            clan.treasury += levelDiff * 50;
            return levelDiff;
        }
        return false;
    };
    
    // Logique de combat avanc√©e
    const simulateBattle = (attacker, defender) => {
        const attackerPower = calculatePower(attacker);
        const defenderPower = calculatePower(defender);
        
        // Facteurs al√©atoires et tactiques
        const attackerLuck = Math.random() * 0.2 + 0.9; // 0.9 √† 1.1
        const defenderLuck = Math.random() * 0.2 + 0.9;
        const defenderBonus = 1.05; // 5% d'avantage d√©fensif
        
        const finalAttackerPower = attackerPower * attackerLuck;
        const finalDefenderPower = defenderPower * defenderLuck * defenderBonus;
        
        const powerDiff = Math.abs(finalAttackerPower - finalDefenderPower);
        const totalPower = finalAttackerPower + finalDefenderPower;
        const diffPercentage = (powerDiff / totalPower) * 100;
        
        let result;
        if (diffPercentage < 5) {
            result = 'draw';
        } else if (finalAttackerPower > finalDefenderPower) {
            result = 'victory';
        } else {
            result = 'defeat';
        }
        
        return {
            result,
            attackerPower: Math.round(finalAttackerPower),
            defenderPower: Math.round(finalDefenderPower),
            powerDiff: Math.round(powerDiff),
            diffPercentage: Math.round(diffPercentage * 10) / 10
        };
    };
    
    // Calcul des pertes avec v√©rifications
    const calculateLosses = (clan, severity = 'medium') => {
        const multipliers = {
            light: { min: 0.05, max: 0.1 },
            medium: { min: 0.1, max: 0.2 },
            heavy: { min: 0.15, max: 0.3 }
        };
        
        const mult = multipliers[severity];
        const lossRate = Math.random() * (mult.max - mult.min) + mult.min;
        
        const losses = {
            w: Math.max(0, Math.floor(clan.units.w * lossRate)),
            a: Math.max(0, Math.floor(clan.units.a * lossRate)),
            m: Math.max(0, Math.floor(clan.units.m * lossRate))
        };
        
        // Appliquer les pertes avec v√©rifications
        clan.units.w = Math.max(0, clan.units.w - losses.w);
        clan.units.a = Math.max(0, clan.units.a - losses.a);
        clan.units.m = Math.max(0, clan.units.m - losses.m);
        
        return losses.w + losses.a + losses.m;
    };
    
    const save = async () => {
        try {
            ctx.clanData = data;
            await saveDataImmediate();
        } catch (error) {
            ctx.log.error("‚ùå Erreur sauvegarde clans:", error);
            throw new Error("Erreur de sauvegarde");
        }
    };
    
    // Validation des donn√©es
    const validateClanData = (clan) => {
        if (!clan) return false;
        
        // V√©rifications de base
        if (!clan.id || !clan.name || !clan.leader || !Array.isArray(clan.members)) {
            return false;
        }
        
        // V√©rifications num√©riques
        clan.level = Math.max(1, clan.level || 1);
        clan.xp = Math.max(0, clan.xp || 0);
        clan.treasury = Math.max(0, clan.treasury || 0);
        
        // V√©rifications unit√©s
        if (!clan.units) clan.units = { w: 0, a: 0, m: 0 };
        clan.units.w = Math.max(0, clan.units.w || 0);
        clan.units.a = Math.max(0, clan.units.a || 0);
        clan.units.m = Math.max(0, clan.units.m || 0);
        
        // V√©rifications membres
        clan.members = clan.members.filter((m, i, arr) => arr.indexOf(m) === i); // Supprimer doublons
        if (clan.members.length > GAME_CONFIG.MAX_MEMBERS) {
            clan.members = clan.members.slice(0, GAME_CONFIG.MAX_MEMBERS);
        }
        
        // V√©rifier que le leader est dans les membres
        if (!clan.members.includes(clan.leader)) {
            clan.members.unshift(clan.leader);
        }
        
        return true;
    };
    
    // Notification am√©lior√©e
    const notifyBattle = async (defenderId, attackerName, defenderName, battleResult) => {
        const resultEmojis = {
            victory: 'üíÄ D√âFAITE',
            defeat: 'üèÜ VICTOIRE',
            draw: 'ü§ù MATCH NUL'
        };
        
        const msg = `‚öîÔ∏è **BATAILLE TERMIN√âE !**\nüè∞ ${attackerName} a attaqu√© ${defenderName}\n${resultEmojis[battleResult.result]} pour toi !\nüìä Puissance: ${battleResult.defenderPower} vs ${battleResult.attackerPower}`;
        
        try {
            await sendMessage(defenderId, msg);
        } catch (err) {
            ctx.log.debug(`‚ùå Notification bataille non envoy√©e √† ${defenderId}`);
        }
    };
    
    // === COMMANDES ===
    
    switch (action) {
        case 'create':
            const newClanName = args_parts.slice(1).join(' ').trim();
            if (!newClanName) {
                return "‚öîÔ∏è **CR√âER UN CLAN**\n\nUsage: `/clan create [nom]`\nExemple: `/clan create Dragons Noirs` üêâ\n\nüìã **R√®gles:**\n‚Ä¢ Nom unique (2-30 caract√®res)\n‚Ä¢ Pas de caract√®res sp√©ciaux\n‚Ä¢ Un seul clan par personne";
            }
            
            if (newClanName.length < 2 || newClanName.length > 30) {
                return "‚ùå Le nom doit faire entre 2 et 30 caract√®res !";
            }
            
            if (getUserClan()) return "‚ùå Tu as d√©j√† un clan ! Utilise `/clan leave` d'abord.";
            
            if (!canCreateClan()) {
                const timeLeft = formatTime(getCooldownTime());
                return `‚ùå Tu as supprim√© un clan r√©cemment !\n‚è∞ Attends encore **${timeLeft}** pour en cr√©er un nouveau.`;
            }
            
            if (findClan(newClanName)) return `‚ùå Le nom "${newClanName}" existe d√©j√† ! Choisis autre chose.`;
            
            const clanId = generateId('clan');
            const newClan = {
                id: clanId,
                name: newClanName,
                leader: userId,
                members: [userId],
                level: 1,
                xp: 0,
                treasury: 100,
                units: { w: 10, a: 5, m: 2 },
                lastDefeat: null,
                lastBattles: {},
                created: Date.now()
            };
            
            if (!validateClanData(newClan)) {
                return "‚ùå Erreur lors de la cr√©ation du clan !";
            }
            
            data.clans[clanId] = newClan;
            data.userClans[userId] = clanId;
            await save();
            
            ctx.log.info(`üè∞ Nouveau clan cr√©√©: ${newClanName} (${clanId}) par ${userId}`);
            return `üéâ **CLAN CR√â√â AVEC SUCC√àS !**\n\nüè∞ **"${newClanName}"** (ID: **${clanId}**)\nüëë Chef: Toi\nüìä Puissance: ${calculatePower(newClan)} pts\n\nüí∞ **Ressources de d√©part:**\n‚Ä¢ 100 pi√®ces d'or\n‚Ä¢ 10 guerriers üó°Ô∏è\n‚Ä¢ 5 archers üèπ\n‚Ä¢ 2 mages üîÆ\n\n‚≠ê Niveau 1 ‚Ä¢ 0/1000 XP\n\nüí° **Prochaines √©tapes:**\n‚Ä¢ Invite des amis: \`/clan invite @ami\`\n‚Ä¢ Consulte ton clan: \`/clan info\`\n‚Ä¢ Lance des batailles: \`/clan battle [cible]\``;

        case 'info':
            const clan = getUserClan();
            if (!clan) {
                addToMemory(userId, 'user', `/clan ${args}`);
                const response = "‚ùå Tu n'as pas de clan !\n\nüè∞ Cr√©e ton clan: `/clan create [nom]`\nüìú Voir tous les clans: `/clan list`\n‚ùì Guide complet: `/clan help`";
                addToMemory(userId, 'assistant', response);
                return response;
            }
            
            if (!validateClanData(clan)) {
                return "‚ùå Donn√©es du clan corrompues ! Contacte un administrateur.";
            }
            
            const nextXP = (clan.level * GAME_CONFIG.XP_PER_LEVEL) - clan.xp;
            const protection = isProtected(clan) ? 'üõ°Ô∏è **PROT√âG√â** ' : '';
            const totalPower = calculatePower(clan);
            const xpProgress = Math.floor((clan.xp % GAME_CONFIG.XP_PER_LEVEL) / GAME_CONFIG.XP_PER_LEVEL * 100);
            
            // Calcul des bonus d√©taill√©s
            const levelBonus = clan.level * 100 + Math.pow(clan.level, 1.2) * 10;
            const memberBonus = clan.members.length * 30;
            const unitPower = clan.units.w * 10 + clan.units.a * 8 + clan.units.m * 15;
            
            addToMemory(userId, 'user', `/clan ${args}`);
            const infoResponse = `üè∞ **${clan.name}** (ID: ${clan.id}) ${protection}\n\nüìä **PUISSANCE TOTALE: ${totalPower} POINTS**\n‚≠ê Niveau ${clan.level} (+${Math.floor(levelBonus)} pts)\nüë• ${clan.members.length}/${GAME_CONFIG.MAX_MEMBERS} membres (+${memberBonus} pts)\nüí∞ ${clan.treasury} pi√®ces d'or\n\n‚ú® **Progression:** ${clan.xp} XP (${nextXP} pour niveau ${clan.level + 1})\n‚ñì${'‚ñà'.repeat(Math.floor(xpProgress/10))}${'‚ñë'.repeat(10-Math.floor(xpProgress/10))} ${xpProgress}%\n\n‚öîÔ∏è **ARM√âE** (+${unitPower} pts):\nüó°Ô∏è **${clan.units.w} Guerriers** (+${clan.units.w * 10} pts)\nüèπ **${clan.units.a} Archers** (+${clan.units.a * 8} pts)\nüîÆ **${clan.units.m} Mages** (+${clan.units.m * 15} pts)\n\n${clan.members.length >= 10 ? `üí´ **BONUS SYNERGIE:** +${clan.members.length * 5} pts\n` : ''}üìà **Analyse tactique:**\n‚Ä¢ Efficacit√©: ${Math.floor(unitPower / Math.max(1, clan.units.w + clan.units.a + clan.units.m) * 10) / 10}/unit√©\n‚Ä¢ Diversit√©: ${[clan.units.w > 0, clan.units.a > 0, clan.units.m > 0].filter(Boolean).length}/3 types (+${[clan.units.w > 0, clan.units.a > 0, clan.units.m > 0].filter(Boolean).length * 20} pts)\n\nüí° Tape \`/clan strategy\` pour les conseils avanc√©s !`;
            addToMemory(userId, 'assistant', infoResponse);
            return infoResponse;

        case 'strategy':
            const strategyClan = getUserClan();
            if (!strategyClan) return "‚ùå Tu n'as pas de clan ! Cr√©e-en un d'abord.";
            
            const power = calculatePower(strategyClan);
            const avgPower = Object.values(data.clans).reduce((sum, c) => sum + calculatePower(c), 0) / Object.keys(data.clans).length;
            
            let strategyText = `üß† **STRAT√âGIES AVANC√âES POUR ${strategyClan.name}**\n\n`;
            
            // Analyse de force
            if (power > avgPower * 1.2) {
                strategyText += `üí™ **STATUT: DOMINANT** (${Math.floor(power/avgPower*100)}% de la moyenne)\nüéØ Attaque les clans moyens pour XP facile\nüõ°Ô∏è Les autres clans t'√©viteront\n`;
            } else if (power < avgPower * 0.8) {
                strategyText += `üìà **STATUT: EN D√âVELOPPEMENT** (${Math.floor(power/avgPower*100)}% de la moyenne)\nüéØ Concentre-toi sur le recrutement\nüí∞ √âconomise pour des mages\n‚ö†Ô∏è √âvite les gros clans\n`;
            } else {
                strategyText += `‚öñÔ∏è **STATUT: √âQUILIBR√â** (${Math.floor(power/avgPower*100)}% de la moyenne)\nüéØ Cherche des cibles similaires\nüìä Diversifie ton arm√©e\n`;
            }
            
            strategyText += `\nüèÜ **OPTIMISATIONS RECOMMAND√âES:**\n`;
            
            // Conseils sp√©cifiques
            if (strategyClan.members.length < 5) {
                strategyText += `üë• **PRIORIT√â: Recrutement** (+${(10-strategyClan.members.length)*30} pts potentiels)\n`;
            }
            
            if (strategyClan.units.m < strategyClan.units.w / 3) {
                strategyText += `üîÆ **Plus de mages** (meilleur ratio puissance/co√ªt)\n`;
            }
            
            if (strategyClan.treasury > 200) {
                strategyText += `üí∞ **D√©pense ton or** (${strategyClan.treasury} pi√®ces en trop)\n`;
            }
            
            const unitTypes = [strategyClan.units.w > 0, strategyClan.units.a > 0, strategyClan.units.m > 0].filter(Boolean).length;
            if (unitTypes < 3) {
                strategyText += `üé® **Diversifie ton arm√©e** (+${(3-unitTypes)*20} pts bonus)\n`;
            }
            
            strategyText += `\nüìä **CALCULS D√âTAILL√âS:**\n`;
            strategyText += `‚Ä¢ Niveau: ${strategyClan.level * 100 + Math.floor(Math.pow(strategyClan.level, 1.2) * 10)} pts\n`;
            strategyText += `‚Ä¢ Membres: ${strategyClan.members.length * 30} pts\n`;
            strategyText += `‚Ä¢ Unit√©s: ${strategyClan.units.w * 10 + strategyClan.units.a * 8 + strategyClan.units.m * 15} pts\n`;
            strategyText += `‚Ä¢ XP: ${Math.floor(strategyClan.xp / 100) * 5} pts\n`;
            strategyText += `‚Ä¢ Diversit√©: ${unitTypes * 20} pts\n`;
            if (strategyClan.members.length >= 10) {
                strategyText += `‚Ä¢ Synergie: ${strategyClan.members.length * 5} pts\n`;
            }
            
            strategyText += `\nüí° **CONSEILS √âCONOMIQUES:**\n`;
            strategyText += `‚Ä¢ Mage = 80üí∞ pour +15 pts (5.3 pts/üí∞)\n`;
            strategyText += `‚Ä¢ Guerrier = 40üí∞ pour +10 pts (4 pts/üí∞)\n`;
            strategyText += `‚Ä¢ Archer = 60üí∞ pour +8 pts (3.75 pts/üí∞)\n`;
            strategyText += `‚Ä¢ **Conclusion:** Privil√©gie les MAGES ! üîÆ`;
            
            return strategyText;

        case 'battle':
            const attackerClan = getUserClan();
            if (!attackerClan) return "‚ùå Tu n'as pas de clan !";
            if (!validateClanData(attackerClan)) return "‚ùå Donn√©es du clan invalides !";
            
            const enemyArg = args_parts[1];
            if (!enemyArg) return "‚öîÔ∏è **LANCER UNE BATAILLE**\n\nUsage: `/clan battle [id ou nom]`\nExemples:\n‚Ä¢ `/clan battle A7B2`\n‚Ä¢ `/clan battle Dragons`\n\nüí° Voir les cibles: `/clan list`";
            
            const enemyClan = findClan(enemyArg);
            if (!enemyClan) return `‚ùå Clan "${enemyArg}" introuvable !\nüí° V√©rifie avec \`/clan list\``;
            if (!validateClanData(enemyClan)) return "‚ùå Donn√©es du clan ennemi invalides !";
            
            if (enemyClan.id === attackerClan.id) return "‚ùå Tu ne peux pas t'attaquer toi-m√™me !";
            
            // V√©rifications de protection et cooldown
            if (isProtected(enemyClan)) {
                const protectionLeft = formatTime(GAME_CONFIG.PROTECTION_TIME - (Date.now() - enemyClan.lastDefeat));
                return `üõ°Ô∏è **${enemyClan.name} est prot√©g√© !**\n‚è∞ Protection restante: ${protectionLeft}`;
            }
            
            if (!canBattleAgainst(attackerClan, enemyClan)) {
                const nextBattle = formatTime(getNextBattleTime(attackerClan, enemyClan));
                return `‚è≥ **Cooldown actif !**\nTu as d√©j√† combattu ${enemyClan.name} r√©cemment.\n‚è∞ Prochain combat possible dans: ${nextBattle}\n\nüí° Tu peux attaquer d'autres clans en attendant !`;
            }
            
            // V√©rification des unit√©s minimales
            const attackerUnits = attackerClan.units.w + attackerClan.units.a + attackerClan.units.m;
            const defenderUnits = enemyClan.units.w + enemyClan.units.a + enemyClan.units.m;
            
            if (attackerUnits === 0) return "‚ùå Tu n'as plus d'unit√©s ! Ach√®te des renforts avec `/clan units`";
            if (defenderUnits === 0) return "‚ùå Le clan ennemi n'a plus d'unit√©s ! Trouve une autre cible.";
            
            // Simulation de bataille
            const battleResult = simulateBattle(attackerClan, enemyClan);
            
            // Application des r√©sultats avec v√©rifications
            const rewards = GAME_CONFIG.BATTLE_REWARDS[battleResult.result];
            
            // XP et niveaux
            const attackerLevelUp = addXP(attackerClan, rewards.xp);
            const defenderXP = battleResult.result === 'victory' ? 50 : battleResult.result === 'defeat' ? 150 : 100;
            const defenderLevelUp = addXP(enemyClan, defenderXP);
            
            // Or avec v√©rifications
            attackerClan.treasury = Math.max(0, attackerClan.treasury + rewards.gold);
            const enemyGoldChange = battleResult.result === 'victory' ? -75 : battleResult.result === 'defeat' ? 75 : 0;
            enemyClan.treasury = Math.max(0, enemyClan.treasury + enemyGoldChange);
            
            // Pertes d'unit√©s
            let attackerLosses = 0;
            let defenderLosses = 0;
            
            if (battleResult.result === 'victory') {
                attackerLosses = calculateLosses(attackerClan, 'light');
                defenderLosses = calculateLosses(enemyClan, 'heavy');
                enemyClan.lastDefeat = Date.now();
            } else if (battleResult.result === 'defeat') {
                attackerLosses = calculateLosses(attackerClan, 'heavy');
                defenderLosses = calculateLosses(enemyClan, 'light');
                attackerClan.lastDefeat = Date.now();
            } else {
                attackerLosses = calculateLosses(attackerClan, 'medium');
                defenderLosses = calculateLosses(enemyClan, 'medium');
            }
            
            // Mise √† jour des cooldowns
            if (!attackerClan.lastBattles) attackerClan.lastBattles = {};
            if (!enemyClan.lastBattles) enemyClan.lastBattles = {};
            attackerClan.lastBattles[enemyClan.id] = Date.now();
            enemyClan.lastBattles[attackerClan.id] = Date.now();
            
            // Sauvegarde des statistiques de bataille
            const battleId = generateId('battle');
            data.battles[battleId] = {
                id: battleId,
                timestamp: Date.now(),
                attacker: { id: attackerClan.id, name: attackerClan.name, power: battleResult.attackerPower },
                defender: { id: enemyClan.id, name: enemyClan.name, power: battleResult.defenderPower },
                result: battleResult.result,
                losses: { attacker: attackerLosses, defender: defenderLosses }
            };
            
            // Validation finale des donn√©es
            validateClanData(attackerClan);
            validateClanData(enemyClan);
            
            await save();
            
            // Notification au d√©fenseur
            if (enemyClan.leader !== userId) {
                await notifyBattle(enemyClan.leader, attackerClan.name, enemyClan.name, battleResult);
            }
            
            // R√©sultat de bataille d√©taill√©
            let battleResponse = `‚öîÔ∏è **BATAILLE: ${attackerClan.name} VS ${enemyClan.name}**\n\n`;
            battleResponse += `üìä **ANALYSE TACTIQUE:**\n`;
            battleResponse += `üî• Puissance d'attaque: ${battleResult.attackerPower} pts\n`;
            battleResponse += `üõ°Ô∏è Puissance de d√©fense: ${battleResult.defenderPower} pts\n`;
            battleResponse += `üìà √âcart: ${battleResult.powerDiff} pts (${battleResult.diffPercentage}%)\n\n`;
            
            const resultEmojis = {
                victory: 'üèÜ **VICTOIRE √âCLATANTE !**',
                defeat: 'üíÄ **D√âFAITE CUISANTE...**',
                draw: 'ü§ù **MATCH NUL H√âRO√èQUE !**'
            };
            
            battleResponse += `${resultEmojis[battleResult.result]}\n\n`;
            
            // D√©tails des gains/pertes
            battleResponse += `üìã **R√âSULTATS POUR ${attackerClan.name}:**\n`;
            battleResponse += `‚ú® XP: +${rewards.xp} (${attackerClan.xp}/${attackerClan.level * GAME_CONFIG.XP_PER_LEVEL})\n`;
            battleResponse += `üí∞ Or: ${rewards.gold >= 0 ? '+' : ''}${rewards.gold} (Total: ${attackerClan.treasury})\n`;
            battleResponse += `üíÄ Pertes: ${attackerLosses} unit√©s\n`;
            
            if (attackerLevelUp) {
                battleResponse += `\nüÜô **NIVEAU UP !** Niveau ${attackerClan.level}\n`;
                battleResponse += `üéÅ Bonus: +${attackerLevelUp * 2} guerriers, +${attackerLevelUp} archers, +${Math.floor(attackerLevelUp/2)} mages, +${attackerLevelUp * 50}üí∞\n`;
            }
            
            // Cooldown info
            battleResponse += `\n‚è≥ **Cooldown:** 1h avant de r√©attaquer ${enemyClan.name}\n`;
            
            if (battleResult.result === 'defeat') {
                const protectionTime = formatTime(GAME_CONFIG.PROTECTION_TIME);
                battleResponse += `üõ°Ô∏è **Protection:** ${protectionTime} contre toute attaque\n`;
            }
            
            battleResponse += `\nüí° **Conseil:** `;
            if (battleResult.result === 'victory') {
                battleResponse += `Excellent ! Cherche maintenant des cibles plus fortes pour plus d'XP.`;
            } else if (battleResult.result === 'defeat') {
                battleResponse += `Renforce ton arm√©e et recrute des membres avant la prochaine bataille.`;
            } else {
                battleResponse += `Match serr√© ! Un l√©ger avantage aurait fait la diff√©rence.`;
            }
            
            ctx.log.info(`‚öîÔ∏è Bataille: ${attackerClan.name} (${battleResult.attackerPower}) VS ${enemyClan.name} (${battleResult.defenderPower}) - ${battleResult.result}`);
            return battleResponse;

        case 'list':
            const topClans = Object.values(data.clans)
                .filter(validateClanData)
                .sort((a, b) => {
                    const powerA = calculatePower(a);
                    const powerB = calculatePower(b);
                    if (powerB !== powerA) return powerB - powerA;
                    return b.level - a.level || b.xp - a.xp;
                })
                .slice(0, 15);
            
            if (topClans.length === 0) return "‚ùå Aucun clan ! Cr√©e le premier avec `/clan create [nom]`";
            
            let list = `üèÜ **CLASSEMENT DES CLANS** (Top ${Math.min(15, topClans.length)})\n\n`;
            
            const userClan = getUserClan();
            const totalClans = Object.keys(data.clans).length;
            
            topClans.forEach((clan, i) => {
                const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i+1}.`;
                const protection = isProtected(clan) ? 'üõ°Ô∏è' : '';
                const isUserClan = userClan && clan.id === userClan.id ? 'üëë' : '';
                const totalPower = calculatePower(clan);
                
                // Indicateur de force
                let strengthIndicator = '';
                if (totalPower > 1000) strengthIndicator = 'üî•';
                else if (totalPower > 500) strengthIndicator = '‚ö°';
                else if (totalPower > 250) strengthIndicator = 'üìà';
                
                list += `${medal} **${clan.name}** (${clan.id}) ${protection}${isUserClan}${strengthIndicator}\n`;
                list += `   üìä ${totalPower} pts ‚Ä¢ ‚≠ê Niv.${clan.level} ‚Ä¢ üë• ${clan.members.length}/${GAME_CONFIG.MAX_MEMBERS}\n`;
                list += `   üí∞ ${clan.treasury} ‚Ä¢ ‚öîÔ∏è ${clan.units.w}g/${clan.units.a}a/${clan.units.m}m\n`;
                
                // Analyse tactique rapide
                if (userClan && clan.id !== userClan.id) {
                    const userPower = calculatePower(userClan);
                    const diff = ((totalPower - userPower) / userPower * 100);
                    
                    if (Math.abs(diff) < 10) {
                        list += `   üéØ **Cible id√©ale** (√©cart: ${Math.round(Math.abs(diff))}%)\n`;
                    } else if (diff > 50) {
                        list += `   ‚ö†Ô∏è **Tr√®s dangereux** (+${Math.round(diff)}%)\n`;
                    } else if (diff < -30) {
                        list += `   üíö **Cible facile** (${Math.round(diff)}%)\n`;
                    }
                }
                list += '\n';
            });
            
            // Statistiques globales
            list += `üìä **STATISTIQUES GLOBALES:**\n`;
            list += `‚Ä¢ ${totalClans} clans actifs\n`;
            list += `‚Ä¢ Puissance moyenne: ${Math.round(topClans.reduce((sum, c) => sum + calculatePower(c), 0) / topClans.length)} pts\n`;
            list += `‚Ä¢ ${topClans.filter(c => isProtected(c)).length} clans prot√©g√©s üõ°Ô∏è\n\n`;
            
            if (userClan) {
                const userRank = topClans.findIndex(c => c.id === userClan.id) + 1;
                if (userRank > 0) {
                    list += `üëë **Ton rang:** #${userRank}/${totalClans}\n`;
                } else {
                    list += `üëë **Ton clan:** Hors top 15\n`;
                }
            }
            
            list += `\nüí° **L√©gendes:**\nüõ°Ô∏è Prot√©g√© ‚Ä¢ üëë Ton clan ‚Ä¢ üî• Elite (1000+ pts)\n‚ö° Fort (500+ pts) ‚Ä¢ üìà Montant (250+ pts)`;
            
            return list;

        case 'invite':
            if (!isLeader()) return "‚ùå Seul le chef peut inviter des membres !";
            
            const targetUser = args_parts[1]?.replace(/[<@!>]/g, '');
            if (!targetUser) {
                return "üë• **INVITER UN MEMBRE**\n\nUsage: `/clan invite @utilisateur`\nExemple: `/clan invite @JohnDoe`\n\nüí° **Avantages des membres:**\n‚Ä¢ +30 points de puissance par membre\n‚Ä¢ Bonus de synergie √† 10+ membres\n‚Ä¢ Maximum: 20 membres";
            }
            
            const inviterClan = getUserClan();
            if (!validateClanData(inviterClan)) return "‚ùå Donn√©es du clan invalides !";
            
            if (inviterClan.members.length >= GAME_CONFIG.MAX_MEMBERS) {
                return `‚ùå Clan plein ! (${GAME_CONFIG.MAX_MEMBERS} membres maximum)\nüí° Promeus quelqu'un d'autre en chef et quitte pour faire de la place.`;
            }
            
            if (data.userClans[targetUser]) {
                const existingClan = data.clans[data.userClans[targetUser]];
                return `‚ùå Cette personne est d√©j√† dans le clan "${existingClan?.name || 'Inconnu'}" !`;
            }
            
            // Initialiser les invitations si n√©cessaire
            if (!data.invites[targetUser]) data.invites[targetUser] = [];
            
            if (data.invites[targetUser].includes(inviterClan.id)) {
                return `‚ùå Tu as d√©j√† invit√© cette personne !\nElle peut rejoindre avec: \`/clan join ${inviterClan.id}\``;
            }
            
            // Limitation des invitations (max 3 invitations par clan)
            if (data.invites[targetUser].length >= 3) {
                return "‚ùå Cette personne a d√©j√† 3 invitations en attente ! Elle doit d'abord en traiter.";
            }
            
            data.invites[targetUser].push(inviterClan.id);
            await save();
            
            ctx.log.info(`üì® Invitation envoy√©e: ${targetUser} vers ${inviterClan.name} (${inviterClan.id})`);
            return `üì® **INVITATION ENVOY√âE !**\n\nüë§ ${args_parts[1]} a √©t√© invit√© dans **${inviterClan.name}**\nüÜî Il peut rejoindre avec: \`/clan join ${inviterClan.id}\`\n\nüìä **Apr√®s son arriv√©e:**\n‚Ä¢ Puissance: +30 points\n‚Ä¢ Membres: ${inviterClan.members.length + 1}/${GAME_CONFIG.MAX_MEMBERS}\n${inviterClan.members.length + 1 >= 10 ? '‚Ä¢ üéâ Bonus synergie d√©bloqu√© !\n' : ''}`;

        case 'join':
            const joinArg = args_parts[1];
            
            if (!joinArg) {
                const myInvites = data.invites[userId] || [];
                if (myInvites.length === 0) {
                    return "üì¨ **AUCUNE INVITATION**\n\nTu n'as re√ßu aucune invitation de clan.\n\nüè∞ **Options:**\n‚Ä¢ Cr√©e ton clan: `/clan create [nom]`\n‚Ä¢ Demande une invitation √† un ami\n‚Ä¢ Consulte les clans: `/clan list`";
                }
                
                let inviteList = `üì¨ **TES INVITATIONS** (${myInvites.length})\n\n`;
                
                myInvites.forEach((clanId, i) => {
                    const c = data.clans[clanId];
                    if (c && validateClanData(c)) {
                        const power = calculatePower(c);
                        const protection = isProtected(c) ? 'üõ°Ô∏è' : '';
                        inviteList += `${i+1}. **${c.name}** (${clanId}) ${protection}\n`;
                        inviteList += `   üìä ${power} pts ‚Ä¢ ‚≠ê Niv.${c.level} ‚Ä¢ üë• ${c.members.length}/${GAME_CONFIG.MAX_MEMBERS}\n`;
                        inviteList += `   üí∞ ${c.treasury} ‚Ä¢ ‚öîÔ∏è ${c.units.w}g/${c.units.a}a/${c.units.m}m\n\n`;
                    }
                });
                
                inviteList += `üéØ **Pour rejoindre:**\n\`/clan join [id]\` (ex: \`/clan join ${myInvites[0]}\`)`;
                return inviteList;
            }
            
            if (getUserClan()) return "‚ùå Tu es d√©j√† dans un clan !\nUtilise `/clan leave` d'abord si tu veux changer.";
            
            const joinClan = findClan(joinArg);
            if (!joinClan) return `‚ùå Clan "${joinArg}" introuvable !\nüí° V√©rifie l'ID avec \`/clan join\` (sans arguments)`;
            
            if (!validateClanData(joinClan)) return "‚ùå Donn√©es du clan invalides !";
            
            if (!data.invites[userId]?.includes(joinClan.id)) {
                return `‚ùå Tu n'es pas invit√© dans **${joinClan.name}** !\nüí° Demande une invitation au chef du clan.`;
            }
            
            if (joinClan.members.length >= GAME_CONFIG.MAX_MEMBERS) {
                return `‚ùå **${joinClan.name}** est complet ! (${GAME_CONFIG.MAX_MEMBERS}/${GAME_CONFIG.MAX_MEMBERS})\nüí° Demande au chef de faire de la place.`;
            }
            
            // Rejoindre le clan
            joinClan.members.push(userId);
            data.userClans[userId] = joinClan.id;
            
            // Nettoyer les invitations
            data.invites[userId] = data.invites[userId].filter(id => id !== joinClan.id);
            if (data.invites[userId].length === 0) {
                delete data.invites[userId];
            }
            
            validateClanData(joinClan);
            await save();
            
            ctx.log.info(`üè∞ ${userId} a rejoint le clan: ${joinClan.name} (${joinClan.id})`);
            
            const newPower = calculatePower(joinClan);
            return `üéâ **BIENVENUE DANS ${joinClan.name.toUpperCase()} !**\n\nüè∞ **Informations du clan:**\nüÜî ID: ${joinClan.id}\nüëë Chef: <@${joinClan.leader}>\nüìä Puissance: ${newPower} pts (+30 gr√¢ce √† toi !)\n‚≠ê Niveau ${joinClan.level} ‚Ä¢ üë• ${joinClan.members.length}/${GAME_CONFIG.MAX_MEMBERS}\n\nüí° **Prochaines √©tapes:**\n‚Ä¢ Consulte les stats: \`/clan info\`\n‚Ä¢ Participe aux batailles: \`/clan battle [cible]\`\n‚Ä¢ Apprends les strat√©gies: \`/clan strategy\`\n\n${joinClan.members.length >= 10 ? 'üéä **BONUS SYNERGIE ACTIF !** (+' + (joinClan.members.length * 5) + ' pts)\n' : ''}Bon combat, guerrier ! ‚öîÔ∏è`;

        case 'leave':
            const leaveClan = getUserClan();
            if (!leaveClan) return "‚ùå Tu n'es pas dans un clan !";
            
            if (!validateClanData(leaveClan)) return "‚ùå Donn√©es du clan invalides !";
            
            // Le chef ne peut pas partir si il y a d'autres membres
            if (isLeader() && leaveClan.members.length > 1) {
                const otherMembers = leaveClan.members.filter(id => id !== userId);
                let memberList = "üë• **MEMBRES DISPONIBLES:**\n";
                otherMembers.slice(0, 5).forEach((memberId, i) => {
                    memberList += `${i+1}. <@${memberId}>\n`;
                });
                
                return `‚ùå **TU ES LE CHEF !**\n\nTu ne peux pas partir tant qu'il y a d'autres membres.\n\nüîÑ **Options:**\n‚Ä¢ Promeus un nouveau chef: \`/clan promote @membre\`\n‚Ä¢ Attendre que tous partent (dissolution auto)\n\n${memberList}\nüí° Utilise: \`/clan promote @membre\``;
            }
            
            const leaveClanName = leaveClan.name;
            const wasLeader = isLeader();
            
            if (wasLeader) {
                // Dissolution compl√®te du clan
                const memberCount = leaveClan.members.length;
                leaveClan.members.forEach(memberId => {
                    delete data.userClans[memberId];
                });
                delete data.clans[leaveClan.id];
                data.deletedClans[userId] = Date.now();
                
                await save();
                
                ctx.log.info(`üè∞ Clan dissous: ${leaveClanName} par ${userId} (${memberCount} membres)`);
                
                const cooldownTime = formatTime(GAME_CONFIG.CREATION_COOLDOWN);
                return `üí• **CLAN "${leaveClanName.toUpperCase()}" DISSOUS !**\n\n‚ö∞Ô∏è Le clan et toutes ses ressources ont √©t√© perdus\nüë• ${memberCount} membre(s) lib√©r√©(s)\n\n‚è∞ **Cooldown de cr√©ation:** ${cooldownTime}\nTu pourras cr√©er un nouveau clan dans 3 jours.\n\nüí° **Conseil:** La prochaine fois, transf√®re le leadership avant de partir !`;
            } else {
                // Simple d√©part
                leaveClan.members = leaveClan.members.filter(id => id !== userId);
                delete data.userClans[userId];
                
                validateClanData(leaveClan);
                await save();
                
                ctx.log.info(`üëã ${userId} a quitt√© le clan: ${leaveClanName}`);
                
                const newPower = calculatePower(leaveClan);
                return `üëã **TU AS QUITT√â "${leaveClanName.toUpperCase()}"**\n\nüìâ Puissance du clan: ${newPower} pts (-30)\nüë• Membres restants: ${leaveClan.members.length}/${GAME_CONFIG.MAX_MEMBERS}\n\nüè∞ **Tu peux maintenant:**\n‚Ä¢ Cr√©er ton propre clan: \`/clan create [nom]\`\n‚Ä¢ Rejoindre un autre clan: \`/clan list\`\n‚Ä¢ Attendre d'autres invitations\n\nBonne chance dans tes futures aventures ! ‚öîÔ∏è`;
            }

        case 'units':
            const unitsClan = getUserClan();
            if (!unitsClan) return "‚ùå Tu n'as pas de clan !";
            if (!validateClanData(unitsClan)) return "‚ùå Donn√©es du clan invalides !";
            
            const unitType = args_parts[1]?.toLowerCase();
            const quantity = parseInt(args_parts[2]) || 1;
            
            if (!unitType) {
                const totalUnits = unitsClan.units.w + unitsClan.units.a + unitsClan.units.m;
                const totalUnitPower = unitsClan.units.w * 10 + unitsClan.units.a * 8 + unitsClan.units.m * 15;
                const avgEfficiency = totalUnits > 0 ? (totalUnitPower / totalUnits).toFixed(1) : 0;
                
                return `‚öîÔ∏è **ARM√âE DE ${unitsClan.name.toUpperCase()}**\n\nüìä **UNIT√âS ACTUELLES:**\nüó°Ô∏è **${unitsClan.units.w} Guerriers** (+${unitsClan.units.w * 10} pts)\n   üí∞ Co√ªt: 40 | Efficacit√©: 4.0 pts/üí∞\nüèπ **${unitsClan.units.a} Archers** (+${unitsClan.units.a * 8} pts)\n   üí∞ Co√ªt: 60 | Efficacit√©: 3.75 pts/üí∞\nüîÆ **${unitsClan.units.m} Mages** (+${unitsClan.units.m * 15} pts) ‚≠ê\n   üí∞ Co√ªt: 80 | Efficacit√©: 5.3 pts/üí∞\n\nüìà **STATISTIQUES:**\n‚Ä¢ Total unit√©s: ${totalUnits}\n‚Ä¢ Puissance unit√©s: ${totalUnitPower} pts\n‚Ä¢ Efficacit√© moyenne: ${avgEfficiency} pts/unit√©\n‚Ä¢ Tr√©sorerie: **${unitsClan.treasury} pi√®ces** üí∞\n\nüõí **ACHETER DES UNIT√âS:**\n\`/clan units guerrier [nombre]\` - Tanky et bon march√©\n\`/clan units archer [nombre]\` - √âquilibr√©\n\`/clan units mage [nombre]\` - Le plus efficace ! üåü\n\nüí° **CONSEIL STRAT√âGIQUE:**\nLes mages ont le meilleur rapport puissance/prix !\n${unitsClan.treasury >= 80 ? 'Tu peux acheter des mages maintenant !' : `Il te faut ${80 - unitsClan.treasury} pi√®ces de plus pour un mage.`}`;
            }
            
            if (!isLeader()) {
                return `‚ùå **ACC√àS REFUS√â**\n\nSeul le chef peut acheter des unit√©s !\nüëë Chef actuel: <@${unitsClan.leader}>\n\nüí° Si tu veux g√©rer l'arm√©e, demande au chef de te promouvoir avec \`/clan promote @toi\``;
            }
            
            if (quantity <= 0 || quantity > 100) {
                return "‚ùå Quantit√© invalide ! (1-100 unit√©s maximum par achat)";
            }
            
            let cost = 0, unitKey = '', unitName = '', unitEmoji = '';
            
            if (['guerrier', 'g', 'warrior', 'w'].includes(unitType)) {
                cost = GAME_CONFIG.UNIT_COSTS.w * quantity;
                unitKey = 'w';
                unitName = quantity === 1 ? 'guerrier' : 'guerriers';
                unitEmoji = 'üó°Ô∏è';
            } else if (['archer', 'a'].includes(unitType)) {
                cost = GAME_CONFIG.UNIT_COSTS.a * quantity;
                unitKey = 'a';
                unitName = quantity === 1 ? 'archer' : 'archers';
                unitEmoji = 'üèπ';
            } else if (['mage', 'm'].includes(unitType)) {
                cost = GAME_CONFIG.UNIT_COSTS.m * quantity;
                unitKey = 'm';
                unitName = quantity === 1 ? 'mage' : 'mages';
                unitEmoji = 'üîÆ';
            } else {
                return "‚ùå **TYPE D'UNIT√â INVALIDE**\n\nTypes disponibles:\n‚Ä¢ `guerrier` ou `g` - 40üí∞ (+10 pts)\n‚Ä¢ `archer` ou `a` - 60üí∞ (+8 pts)\n‚Ä¢ `mage` ou `m` - 80üí∞ (+15 pts) ‚≠ê\n\nExemple: `/clan units mage 3`";
            }
            
            if (unitsClan.treasury < cost) {
                const missing = cost - unitsClan.treasury;
                return `‚ùå **FONDS INSUFFISANTS**\n\nüí∞ Co√ªt: **${cost} pi√®ces**\nüí∞ Disponible: **${unitsClan.treasury} pi√®ces**\nüí∞ Manquant: **${missing} pi√®ces**\n\nüí° **Comment gagner de l'or:**\n‚Ä¢ Gagne des batailles (+100üí∞)\n‚Ä¢ Monte de niveau (+50üí∞/niveau)\n‚Ä¢ Attends les bonus quotidiens (bient√¥t !)`;
            }
            
            // Achat des unit√©s
            unitsClan.treasury -= cost;
            unitsClan.units[unitKey] += quantity;
            
            const powerGain = quantity * GAME_CONFIG.UNIT_POWER[unitKey];
            const newPower = calculatePower(unitsClan);
            
            validateClanData(unitsClan);
            await save();
            
            ctx.log.info(`üõí Achat: ${quantity} ${unitName} par ${unitsClan.name} (${cost}üí∞)`);
            
            return `‚úÖ **ACHAT R√âUSSI !**\n\n${unitEmoji} **${quantity} ${unitName}** recrut√©(s) pour **${cost}üí∞**\n\nüìä **NOUVEAUX TOTAUX:**\n‚Ä¢ ${unitEmoji} ${unitName.charAt(0).toUpperCase() + unitName.slice(1)}: ${unitsClan.units[unitKey]}\n‚Ä¢ üí∞ Tr√©sorerie: ${unitsClan.treasury} pi√®ces\n‚Ä¢ üìà Puissance: ${newPower} pts (+${powerGain})\n\n‚öîÔ∏è **Arm√©e totale:** ${unitsClan.units.w}üó°Ô∏è ${unitsClan.units.a}üèπ ${unitsClan.units.m}üîÆ\n\nüí° Ton clan est maintenant plus fort ! Temps de conqu√©rir ! üèÜ`;

        case 'promote':
            if (!isLeader()) {
                const currentClan = getUserClan();
                return `‚ùå **ACC√àS REFUS√â**\n\nSeul le chef peut promouvoir !\nüëë Chef actuel: <@${currentClan?.leader || 'Inconnu'}>\n\nüí° Seul le chef peut transf√©rer son r√¥le √† un autre membre.`;
            }
            
            const newLeader = args_parts[1]?.replace(/[<@!>]/g, '');
            if (!newLeader) {
                const promoteClan = getUserClan();
                const otherMembers = promoteClan.members.filter(id => id !== userId);
                
                let memberList = "üë• **MEMBRES PROMOUVABLES:**\n\n";
                otherMembers.forEach((memberId, i) => {
                    memberList += `${i+1}. <@${memberId}>\n`;
                });
                
                return `üëë **PROMOUVOIR UN NOUVEAU CHEF**\n\nUsage: \`/clan promote @nouveau_chef\`\n\n${memberList}\n‚ö†Ô∏è **ATTENTION:**\n‚Ä¢ Tu perdras le r√¥le de chef d√©finitivement\n‚Ä¢ Le nouveau chef aura tous les pouvoirs\n‚Ä¢ Cette action est irr√©versible\n\nüí° Choisis quelqu'un de confiance !`;
            }
            
            const promoteClan = getUserClan();
            if (!validateClanData(promoteClan)) return "‚ùå Donn√©es du clan invalides !";
            
            if (newLeader === userId) {
                return "‚ùå Tu es d√©j√† le chef ! üëë\nüí° Pour promouvoir quelqu'un d'autre, utilise son ID.";
            }
            
            if (!promoteClan.members.includes(newLeader)) {
                return `‚ùå **MEMBRE INTROUVABLE**\n\n<@${newLeader}> n'est pas membre de **${promoteClan.name}** !\n\nüë• **Membres actuels:** ${promoteClan.members.length}/${GAME_CONFIG.MAX_MEMBERS}\nüí° Invite d'abord cette personne avec \`/clan invite @personne\``;
            }
            
            // Changement de chef
            const oldLeader = promoteClan.leader;
            promoteClan.leader = newLeader;
            
            validateClanData(promoteClan);
            await save();
            
            ctx.log.info(`üëë Nouveau chef: ${newLeader} pour le clan ${promoteClan.name} (${promoteClan.id}), ancien: ${oldLeader}`);
            
            return `üëë **PROMOTION R√âUSSIE !**\n\nüè∞ **${promoteClan.name}** a un nouveau chef !\n\nüëë **Nouveau chef:** <@${newLeader}>\nüë§ **Ancien chef:** <@${oldLeader}> (maintenant membre)\n\nüîÑ **Pouvoirs transf√©r√©s:**\n‚Ä¢ Gestion des membres et invitations\n‚Ä¢ Achat d'unit√©s et gestion du tr√©sor\n‚Ä¢ Lancement des batailles\n‚Ä¢ Promotion d'autres membres\n\nüí° <@${newLeader}>, tu peux maintenant utiliser toutes les commandes de chef !\n\nF√©licitations pour ton nouveau r√¥le ! üéâ`;

        case 'history':
            const historyLimit = parseInt(args_parts[1]) || 10;
            if (historyLimit > 50) return "‚ùå Maximum 50 batailles affichables !";
            
            const userClanHistory = getUserClan();
            if (!userClanHistory) return "‚ùå Tu n'as pas de clan !";
            
            const clanBattles = Object.values(data.battles)
                .filter(battle => battle.attacker.id === userClanHistory.id || battle.defender.id === userClanHistory.id)
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, historyLimit);
            
            if (clanBattles.length === 0) {
                return `üìö **HISTORIQUE DE ${userClanHistory.name.toUpperCase()}**\n\n‚ùå Aucune bataille enregistr√©e !\n\nüéØ **Commence ton aventure:**\n‚Ä¢ Lance ta premi√®re bataille: \`/clan battle [cible]\`\n‚Ä¢ Trouve des cibles: \`/clan list\`\n‚Ä¢ Apprends les strat√©gies: \`/clan strategy\``;
            }
            
            let historyText = `üìö **HISTORIQUE DE ${userClanHistory.name.toUpperCase()}** (${clanBattles.length} derni√®res)\n\n`;
            
            let victories = 0, defeats = 0, draws = 0;
            
            clanBattles.forEach((battle, i) => {
                const isAttacker = battle.attacker.id === userClanHistory.id;
                const enemy = isAttacker ? battle.defender : battle.attacker;
                const ally = isAttacker ? battle.attacker : battle.defender;
                
                let resultIcon = '';
                let resultText = '';
                
                if (battle.result === 'victory') {
                    if (isAttacker) {
                        resultIcon = 'üèÜ';
                        resultText = 'VICTOIRE';
                        victories++;
                    } else {
                        resultIcon = 'üíÄ';
                        resultText = 'D√âFAITE';
                        defeats++;
                    }
                } else if (battle.result === 'defeat') {
                    if (isAttacker) {
                        resultIcon = 'üíÄ';
                        resultText = 'D√âFAITE';
                        defeats++;
                    } else {
                        resultIcon = 'üèÜ';
                        resultText = 'VICTOIRE';
                        victories++;
                    }
                } else {
                    resultIcon = 'ü§ù';
                    resultText = 'MATCH NUL';
                    draws++;
                }
                
                const timeAgo = formatTime(Date.now() - battle.timestamp);
                const role = isAttacker ? 'Attaque sur' : 'D√©fense contre';
                
                historyText += `${i+1}. ${resultIcon} **${resultText}** - ${role} ${enemy.name}\n`;
                historyText += `   üìä ${ally.power} vs ${enemy.power} pts ‚Ä¢ ‚è∞ Il y a ${timeAgo}\n`;
                historyText += `   üíÄ Pertes: ${isAttacker ? battle.losses.attacker : battle.losses.defender} unit√©s\n\n`;
            });
            
            // Statistiques globales
            const totalBattles = victories + defeats + draws;
            const winRate = totalBattles > 0 ? Math.round((victories / totalBattles) * 100) : 0;
            
            historyText += `üìä **STATISTIQUES GLOBALES:**\n`;
            historyText += `üèÜ Victoires: ${victories} (${Math.round(victories/totalBattles*100) || 0}%)\n`;
            historyText += `üíÄ D√©faites: ${defeats} (${Math.round(defeats/totalBattles*100) || 0}%)\n`;
            historyText += `ü§ù Matchs nuls: ${draws} (${Math.round(draws/totalBattles*100) || 0}%)\n`;
            historyText += `üìà **Taux de victoire: ${winRate}%**\n\n`;
            
            // √âvaluation de performance
            if (winRate >= 70) {
                historyText += `‚≠ê **√âVALUATION: CONQU√âRANT** - Excellent travail !`;
            } else if (winRate >= 50) {
                historyText += `üìà **√âVALUATION: GUERRIER** - Performance solide !`;
            } else if (winRate >= 30) {
                historyText += `üîÑ **√âVALUATION: APPRENTI** - Continue tes efforts !`;
            } else {
                historyText += `üí™ **√âVALUATION: D√âBUTANT** - Entra√Æne-toi plus !`;
            }
            
            return historyText;

        case 'kick':
            if (!isLeader()) return "‚ùå Seul le chef peut exclure des membres !";
            
            const targetKick = args_parts[1]?.replace(/[<@!>]/g, '');
            if (!targetKick) {
                const kickClan = getUserClan();
                const members = kickClan.members.filter(id => id !== userId);
                
                if (members.length === 0) {
                    return "‚ùå Il n'y a que toi dans le clan !\nüí° Utilise `/clan invite @ami` pour recruter.";
                }
                
                let memberList = `üë• **MEMBRES EXCLUSIBLES DE ${kickClan.name.toUpperCase()}:**\n\n`;
                members.forEach((memberId, i) => {
                    memberList += `${i+1}. <@${memberId}>\n`;
                });
                
                return `${memberList}\n‚ö†Ô∏è **EXCLUSION D'UN MEMBRE**\nUsage: \`/clan kick @membre\`\n\nüí° **Attention:** Cette action est irr√©versible !\nLe membre devra √™tre r√©-invit√© pour revenir.`;
            }
            
            const kickClan = getUserClan();
            if (!validateClanData(kickClan)) return "‚ùå Donn√©es du clan invalides !";
            
            if (targetKick === userId) {
                return "‚ùå Tu ne peux pas t'exclure toi-m√™me !\nüí° Utilise `/clan leave` pour quitter le clan.";
            }
            
            if (!kickClan.members.includes(targetKick)) {
                return `‚ùå <@${targetKick}> n'est pas membre de **${kickClan.name}** !\nüí° V√©rifie la liste avec \`/clan kick\` (sans arguments).`;
            }
            
            // Exclusion du membre
            kickClan.members = kickClan.members.filter(id => id !== targetKick);
            delete data.userClans[targetKick];
            
            // Supprimer les invitations en attente de ce membre vers d'autres clans
            if (data.invites[targetKick]) {
                delete data.invites[targetKick];
            }
            
            validateClanData(kickClan);
            await save();
            
            ctx.log.info(`üë¢ Exclusion: ${targetKick} du clan ${kickClan.name} par ${userId}`);
            
            const newPower = calculatePower(kickClan);
            return `üë¢ **MEMBRE EXCLU !**\n\n‚ùå <@${targetKick}> a √©t√© exclu de **${kickClan.name}**\n\nüìâ **Impact sur le clan:**\n‚Ä¢ Puissance: ${newPower} pts (-30)\n‚Ä¢ Membres: ${kickClan.members.length}/${GAME_CONFIG.MAX_MEMBERS}\n${kickClan.members.length < 10 && kickClan.members.length >= 9 ? '‚Ä¢ ‚ö†Ô∏è Bonus synergie perdu !\n' : ''}\nüí° **Tu peux inviter quelqu'un d'autre:** \`/clan invite @nouveau\``;

        case 'help':
            return `‚öîÔ∏è **GUIDE COMPLET DES CLANS** - √âdition Avanc√©e\n\nüè∞ **D√âMARRAGE:**\n‚Ä¢ \`/clan create [nom]\` - Cr√©er ton clan (cooldown 3j apr√®s suppression)\n‚Ä¢ \`/clan info\` - Stats d√©taill√©es avec calculs de puissance\n‚Ä¢ \`/clan list\` - Top 15 des clans avec analyse tactique\n‚Ä¢ \`/clan strategy\` - Conseils personnalis√©s pour ton clan\n\nüë• **GESTION D'√âQUIPE:**\n‚Ä¢ \`/clan invite @user\` - Inviter (max 3 invitations par personne)\n‚Ä¢ \`/clan join [id]\` - Rejoindre avec ID court (ex: A3B7)\n‚Ä¢ \`/clan leave\` - Quitter (dissolution si chef seul)\n‚Ä¢ \`/clan promote @user\` - Transf√©rer leadership (irr√©versible)\n‚Ä¢ \`/clan kick @user\` - Exclure un membre (chef seulement)\n\n‚öîÔ∏è **SYST√àME DE COMBAT AVANC√â:**\n‚Ä¢ \`/clan battle [id/nom]\` - Attaquer (cooldown 1h entre m√™mes clans)\n‚Ä¢ \`/clan history [nombre]\` - Historique des batailles\n‚Ä¢ Protection 1h apr√®s d√©faite\n‚Ä¢ Facteurs al√©atoires et bonus d√©fensif (5%)\n\nüõí **GESTION DES UNIT√âS:**\n‚Ä¢ \`/clan units\` - Voir arm√©e et statistiques\n‚Ä¢ \`/clan units guerrier [nb]\` - 40üí∞ (+10 pts, tanky)\n‚Ä¢ \`/clan units archer [nb]\` - 60üí∞ (+8 pts, √©quilibr√©)\n‚Ä¢ \`/clan units mage [nb]\` - 80üí∞ (+15 pts, efficace) ‚≠ê\n\nüìà **CALCUL DE PUISSANCE D√âTAILL√â:**\n‚Ä¢ **Niveau:** 100 + niveau^1.2 √ó 10 pts\n‚Ä¢ **Membres:** 30 pts/personne + synergie (10+ = +5 pts/membre)\n‚Ä¢ **Unit√©s:** Guerriers 10pts, Archers 8pts, Mages 15pts\n‚Ä¢ **XP:** +5 pts par 100 XP accumul√©e\n‚Ä¢ **Diversit√©:** +20 pts par type d'unit√© diff√©rent\n\nüèÜ **R√âSULTATS DE COMBAT:**\n‚Ä¢ **Victoire** (>5% √©cart): +200 XP, +100üí∞, protection ennemi\n‚Ä¢ **Match nul** (‚â§5% √©cart): +100 XP, 0üí∞, pas de protection\n‚Ä¢ **D√©faite** (<-5% √©cart): +50 XP, -50üí∞, protection 1h\n\nüí° **STRAT√âGIES AVANC√âES:**\n‚Ä¢ **Efficacit√© unit√©s:** Mages > Guerriers > Archers (pts/üí∞)\n‚Ä¢ **Recrutement prioritaire:** 10+ membres = bonus synergie\n‚Ä¢ **Timing optimal:** Attaque les clans non-prot√©g√©s\n‚Ä¢ **Diversification:** 3 types d'unit√©s = +60 pts bonus\n‚Ä¢ **√âconomie:** √âquilibre entre unit√©s et membres\n\nüéØ **CONSEILS TACTIQUES:**\n‚Ä¢ √âvite les combats √† puissance √©gale (risque de nul)\n‚Ä¢ Attaque +10% plus faible pour victoire assur√©e\n‚Ä¢ D√©veloppe d'abord les mages (meilleur ROI)\n‚Ä¢ Recrute avant d'investir massivement en unit√©s\n‚Ä¢ Utilise le cooldown pour attaquer d'autres clans\n\n‚ö†Ô∏è **LIMITATIONS IMPORTANTES:**\n‚Ä¢ Cooldown 1h entre batailles contre m√™me clan\n‚Ä¢ Max 20 membres par clan\n‚Ä¢ Max 3 invitations en attente par personne\n‚Ä¢ Cr√©er clan: cooldown 3j apr√®s dissolution\n‚Ä¢ Protection: 1h apr√®s d√©faite (toute attaque)\n\nüèÖ **PROGRESSION:**\n‚Ä¢ 1000 XP = +1 niveau + bonus unit√©s + 50üí∞\n‚Ä¢ Niveau up donne: +2 guerriers, +1 archer, +0.5 mage\n‚Ä¢ Batailles donnent XP m√™me en cas de d√©faite\n‚Ä¢ Plus l'ennemi est fort, plus l'XP est importante\n\nMa√Ætrise ces m√©caniques pour dominer le classement ! üëë`;

        default:
            const userClan = getUserClan();
            if (userClan) {
                if (!validateClanData(userClan)) {
                    return "‚ùå Donn√©es du clan corrompues ! Contacte un administrateur.";
                }
                
                const protection = isProtected(userClan) ? 'üõ°Ô∏è Prot√©g√© ' : '';
                const power = calculatePower(userClan);
                const role = isLeader() ? 'üëë Chef' : 'üë§ Membre';
                
                return `üè∞ **${userClan.name}** (${userClan.id}) ${protection}\n${role} ‚Ä¢ ‚≠ê Niv.${userClan.level} ‚Ä¢ üìä ${power} pts\nüë• ${userClan.members.length}/${GAME_CONFIG.MAX_MEMBERS} ‚Ä¢ üí∞ ${userClan.treasury}üí∞\n‚öîÔ∏è ${userClan.units.w}üó°Ô∏è ${userClan.units.a}üèπ ${userClan.units.m}üîÆ\n\nüí° **COMMANDES RAPIDES:**\n‚Ä¢ \`/clan info\` - Statistiques d√©taill√©es\n‚Ä¢ \`/clan battle [cible]\` - Lancer une attaque\n‚Ä¢ \`/clan strategy\` - Conseils personnalis√©s\n‚Ä¢ \`/clan help\` - Guide complet\n\nüéØ **PROCHAINE √âTAPE RECOMMAND√âE:**\n${userClan.members.length < 5 ? 'üë• Recrute des membres pour +30 pts chacun !' : userClan.treasury >= 80 ? 'üîÆ Ach√®te des mages (meilleur ratio) !' : power < 300 ? '‚öîÔ∏è Lance des batailles pour gagner XP et or !' : 'üèÜ Tu es pr√™t √† affronter les plus forts !'}`;
            } else {
                return `‚öîÔ∏è **BIENVENUE DANS LE SYST√àME DE CLANS ULTIME !**\n\nüåü **Syst√®me nouvelle g√©n√©ration avec:**\n‚Ä¢ Combat tactique avanc√© avec facteurs al√©atoires\n‚Ä¢ Calculs de puissance complexes et bonus\n‚Ä¢ Syst√®me de protection et cooldowns intelligents\n‚Ä¢ √âconomie √©quilibr√©e et strat√©gies multiples\n\nüöÄ **D√âMARRAGE RAPIDE:**\nüè∞ \`/clan create [nom]\` - Fonde ton empire\nüìú \`/clan list\` - Explore les rivaux\n‚ùì \`/clan help\` - Ma√Ætrise toutes les m√©caniques\n\nüíé **POURQUOI CR√âER UN CLAN ?**\n‚Ä¢ Combats √©piques avec syst√®me tactique\n‚Ä¢ Progression par niveaux et exp√©rience\n‚Ä¢ Gestion d'arm√©e et √©conomie\n‚Ä¢ Classements et comp√©tition\n‚Ä¢ Coop√©ration et strat√©gies d'√©quipe\n\nüéØ **Cr√©e ton clan maintenant et commence ta conqu√™te !**\n\nüí° Tape \`/clan create [nom]\` pour d√©buter l'aventure !`;
    }
};

// === FONCTIONS UTILITAIRES EXPORT√âES ===

// Fonction de nettoyage automatique (√† appeler p√©riodiquement)
module.exports.cleanupClanData = async function(ctx) {
    if (!ctx.clanData) return;
    
    let cleaned = 0;
    const now = Date.now();
    
    // Nettoyer les invitations expir√©es (7 jours)
    Object.keys(ctx.clanData.invites).forEach(userId => {
        const validInvites = ctx.clanData.invites[userId].filter(clanId => {
            return ctx.clanData.clans[clanId]; // Clan existe encore
        });
        
        if (validInvites.length === 0) {
            delete ctx.clanData.invites[userId];
            cleaned++;
        } else if (validInvites.length !== ctx.clanData.invites[userId].length) {
            ctx.clanData.invites[userId] = validInvites;
            cleaned++;
        }
    });
    
    // Nettoyer les cooldowns de suppression expir√©s
    Object.keys(ctx.clanData.deletedClans).forEach(userId => {
        if (now - ctx.clanData.deletedClans[userId] > 7 * 24 * 60 * 60 * 1000) { // 7 jours
            delete ctx.clanData.deletedClans[userId];
            cleaned++;
        }
    });
    
    // Nettoyer les batailles anciennes (garder 30 jours)
    const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
    Object.keys(ctx.clanData.battles).forEach(battleId => {
        if (ctx.clanData.battles[battleId].timestamp < thirtyDaysAgo) {
            delete ctx.clanData.battles[battleId];
            cleaned++;
        }
    });
    
    if (cleaned > 0) {
        await ctx.saveDataImmediate();
        ctx.log.info(`üßπ Nettoyage clans: ${cleaned} entr√©es supprim√©es`);
    }
};

// Fonction de validation globale
module.exports.validateAllClans = async function(ctx) {
    if (!ctx.clanData) return;
    
    let fixed = 0;
    
    Object.values(ctx.clanData.clans).forEach(clan => {
        if (!validateClanData(clan)) {
            ctx.log.warn(`üîß Clan ${clan.name} (${clan.id}) corrig√© automatiquement`);
            fixed++;
        }
    });
    
    if (fixed > 0) {
        await ctx.saveDataImmediate();
        ctx.log.info(`üîß ${fixed} clans corrig√©s automatiquement`);
    }
};
